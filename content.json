{"meta":{"title":"A coder's life","subtitle":"Thinking, coding and writing. Giving, loving and sharing.","description":"Thinking, coding and writing. Giving, loving and sharing.","author":"Richard Hsueh","url":"http://www.gistop.com"},"pages":[{"title":"","date":"2018-08-26T06:43:44.975Z","updated":"2018-08-26T06:43:44.975Z","comments":true,"path":"categories.json","permalink":"http://www.gistop.com/categories.json","excerpt":"","text":"{\"categories\":[{\"name\":\"thinking\",\"desp\":\"\",\"children\":[]},{\"name\":\"coding\",\"desp\":\"\",\"children\":[]},{\"name\":\"writing\",\"desp\":\"\",\"children\":[]},{\"name\":\"giving\",\"desp\":\"\",\"children\":[]},{\"name\":\"loving\",\"desp\":\"\",\"children\":[]},{\"name\":\"sharing\",\"desp\":\"\",\"children\":[]}]}"},{"title":"Tags","date":"2016-12-25T12:07:29.000Z","updated":"2018-08-26T06:43:45.234Z","comments":true,"path":"tags/index.html","permalink":"http://www.gistop.com/tags/index.html","excerpt":"","text":""},{"title":"About","date":"2016-12-25T12:15:45.000Z","updated":"2018-08-26T06:43:44.975Z","comments":true,"path":"about/index.html","permalink":"http://www.gistop.com/about/index.html","excerpt":"","text":""},{"title":"Categories Index","date":"2016-12-25T12:15:45.000Z","updated":"2018-08-26T06:43:44.975Z","comments":true,"path":"categories/index.html","permalink":"http://www.gistop.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"供应链战略","slug":"supply-chain-strategy","date":"2018-08-26T07:00:26.000Z","updated":"2018-08-26T07:04:49.824Z","comments":true,"path":"2018/08/26/supply-chain-strategy/","link":"","permalink":"http://www.gistop.com/2018/08/26/supply-chain-strategy/","excerpt":"供应链战略概述 所谓供应链战略就是从企业战略的高度来对供应链进行全局性规划，它确定原材料的获取和运输，产品的制造或服务的提供，以及产品配送和售后服务的方式与特点。供应链战略突破了一般战略规划仅仅关注企业本身的局限，通过在整个供应链上进行规划，进而实现为企业获取竞争优势的目的。供应链战略管理所关注的重点不是企业向顾客提供的产品或服务本身给企业增加的竞争优势，而是产品或服务在企业内部和整个供应链中运动的流程所创造的市场价值给企业增加的竞争优势。","text":"供应链战略概述 所谓供应链战略就是从企业战略的高度来对供应链进行全局性规划，它确定原材料的获取和运输，产品的制造或服务的提供，以及产品配送和售后服务的方式与特点。供应链战略突破了一般战略规划仅仅关注企业本身的局限，通过在整个供应链上进行规划，进而实现为企业获取竞争优势的目的。供应链战略管理所关注的重点不是企业向顾客提供的产品或服务本身给企业增加的竞争优势，而是产品或服务在企业内部和整个供应链中运动的流程所创造的市场价值给企业增加的竞争优势。 费希尔根据产品的需求模式将供应链战略划分为两类：有效性供应链战略和反应性供应链战略。费希尔按需求模式将产品分为两类，即：功能性产品和创新性产品。功能性产品包括可以从大量零售店买到的主要商品，这些产品满足基本需求，需求稳定且可以预测，并且生命周期长。但是，稳定性意味着竞争较激烈，进而导致利润较低。创新性产品指满足特定需求而生产的产品，企业在产品式样上或技术上进行创新以满足顾客的特殊需求。尽管创新性产品能使企业获得更高的利润，但是，创新性产品的新颖却使需求不可预测，而且产品的寿命周期一般较短。 有效性供应链战略是指能够以最低成本将原材料转化成零部件、半成品、成品，以及在供应链中的运输等的供应链战略。由于功能性产品的需求可以预测，生产该类产品的企业可以采取各种措施降低成本，在低成本的前提下妥善安排订单、完成生产和产品交付，使供应链存货最小化和生产效率最大化。因此，生产功能性产品的企业应该采用有效性供应链战略。反应性供应链战略是强调快速对需求做出反应的供应链战略，所对应的产品是创新性产品。这是因为创新性产品所面临的市场是非常不确定的，产品的寿命周期也比较短，企业面临的重要问题是快速把握需求的变化并能够及时对变化做出有效反应以适应需求的变化。 通过产品需求划分供应链战略的方式为企业选择供应链战略提供了依据，但是实践中，很多企业在规划供应链战略和开展供应链战略管理中却存在种种问题。以下首先分析国内供应链战略管理存在的问题，然后提出有关供应链战略管理的对策。 供应链战略管理现状第一，对供应链管理思想认识不足。 由于供应链管理在我国还是—个比较新的概念，再加上我国企业原来的管理思想较落后，许多管理者对供应链管理的理解是片面的和错误的。很多管理者对横向一体化、业务外包等管理思想认识不够，还停留在原有大而全的纵向一体化管理思想上。有些管理者把供应链管理与物流管理、电于商务混淆起来，另外一些管理者则把供应链管理理解为供应管理。实际上，物流管理只是供应链管理中的— 个组成部分，而电子商务则是供应链管理过程中部分环节的电子化实现形式，供应链管理涵盖的范围很广，供应管理仅仅是其中一个环节而已。 第二，供应链战略没有得到足够的重视。 很多企业仅仅是将供应链管理作为一种管理方法来看待，认为供应链管理是一个操作层上的问题，是对企业的生产和供应进行优化的方法而已。即使在国外的很多企业中，供应链战略也为得到足够的重视。Deloitte管理咨询公司对北美制造企业供应链管理进行研究发现众多企业难以成功实施供应链管理的一个重要原因就在于这些企业没有正规的供应链战略。 第三，供应链战略与其他战略的匹配存在问题。 供应链战略作为企业的一项职能战略，需要与企业的竞争战略以及其他职能战略密切配合，才能保证供应链管理的成功实施。但是在很多企业中，本来需要密切配合的不同战略之间却是孤立的。在制定供应链以及相关战略的过程中，没有能够从全局的角度系统地考虑战略制定问题，导致不同战略之间不匹配，在实施的过程中由于不匹配而难以发挥供应链管理的真正优势。 第四，供应链战略合作关系有待加强。 建立战略性合作伙伴是供应链战略管理的重点，也是供应链管理的核心。供应链管理的关键就在于供应链各节点企业之间的联接和合作，以及相互之间在设计、生产、竞争策略等方面良好的协调。但是，很多国内企业与合作伙伴的关系还停留在旧模式下的合作关系之上，企业之间的关系还是一种不稳定、以价格作为唯一标准的买卖关系。供应链上不同企业之间稳定的、有效信息资源共享、共同制定相关决策、利益共享的战略合作伙伴关系还鲜有出现，企业之间的供应链战略合作关系有待建立和加强。 供应链战略管理对策(一)正确认识供应链管理思想 企业在实施供应链管理之前必须建立正确的供应链管理思想，并以供应链管理思想来指导供应链战略规划和实施。供应链管理的基本管理思想主要包括：“横向一体化”的管理思想，也就是集中资源建立核心竞争优势；非核心业务外包，与业务伙伴结成战略联盟关系；供应链企业形成一种合作性竞争关系；以顾客满意度作为目标的服务化管理；追求物流、信息流、资金流、工作流和组织流的集成；借助信息技术实现目标管理等。企业必须树立这些管理思想，并在供应链管理过程中认真贯彻这些思想，保证供应链管理的成功实施。 (二)从战略高度规划供应链管理 供应链管理不是一种单纯地对生产和供应进行优化的方法，而是需要从战略层上来考虑的一个重要问题。供应链管理是对传统的企业内部各业务部门间以及企业之间的职能从整个供应链进行系统的、战略性的协调，目的是提高供应链以及每个企业的长期绩效。企业必须从战略上重视供应链管理，并对其进行战略上长远的规划。 (三)全面系统规划供应链及相关战略以实现战略匹配 企业在开展供应链管理时，需要从系统的观点出发，通过全面规划相关战略，以实现供应链战略、企业基本竞争战略以及其他职能战略之间的协调一致。首先，企业的供应链战略必须和企业竞争战略相互匹配。波特提出了三种基本竞争战略，即低成本战略、差异化战略和目标集聚战略。而企业供应链战略可以分成有效性供应链战略和反应性供应链战略。其中，有效性供应链战略需要与低成本竞争战略相匹配，而反应性供应链战略需要与差异化或者目标集聚的竞争战略相匹配。 其次，供应链战略作为一种职能战略，需要与新产品开发战略以及市场营销等其他职能战略相互匹配。对于反应性供应链战略而言，新产品开发和营销战略都需要围绕提高反应能力来设计。新产品开发战略就需要使顾客和供应商及时参与新产品的设计和开发，提高企业的反应能力。市场营销战略就要求建立足够的零售网络、避免缺货、与客户进行良好的沟通、有效的广告和促销活动；对于有效性供应链战略而言，新产品开发和营销战略都要围绕降低成本来设计。新产品开发战略需要通过尽量采用标准件和通用件来降低成本。营销战略的目的则要求定位于在扩大市场占有率的基础上，尽量降低销售成本。 (四)建立供应链管理的战略支撑体系 国内企业在开展供应链管理的过程中，需要建立起供应链战略的支撑体系，以保证供应链战略的成功实施。所谓供应链管理的战略支撑体系指的是培育企业的核心竞争力、实施业务外包以及建立战略合作伙伴关系。 核心竞争力是企业供应链战略规划、实施的基础和前提，企业在进行供应链管理时，必须了解自己核心竞争力，并以此为基础来规划和构建供应链，而且在实施过程中集中有限资源不断培育核心竞争力；业务外包是供应链战略实现的有效途径。供应链管理的目的在于建立竞争优势，为了实现这一目的，必然要求在集中资源于核心业务的同时，开展业务外包。通过业务外包减少长期资本投资、合理利用资源以及有效平衡企业的关键能力，最终实现提高竞争优势的战略目的；战略合作伙伴关系是供应链战略成功的保证。供应链战略突破传统战略规划仅仅关注企业内部的局限，实现整个供应链价值最大化，这必然要求供应链各节点企业之间的联接和合作，以及相互之间在设计、生产、竞争策略等方面良好的协调，也就是建立战略合作伙伴关系。只有建立并不断培育战略合作伙伴关系，才能实现供应链战略的目标。 提升供应链战略的策略 过去，企业通过控制他们的各个作业部门的成本来实现供应链的增值。虽然他们所采取的方法不同，但是一个共同点就是仍然停留在传统的成本控制模式和运作管理的层面。80年代至90年代，供应链管理工具主要包括物料资源计划、准时制生产、看板管理、持续改进、快速响应和全面质量管理。这些工具都很难达到实现供应链价值最大化和提高价值链水平的目的。也就是说，以成本为中心的供应链管理已经落后了。 竞争优势、电子商务、产品多样化、供应资源的多样化和日益提高的客户要求对现存的供应链模式提出更严酷的挑战。首先，企业必须认清怎样发掘供应链潜在的战略价值，继而确定供应链在企业价值最大化中所扮演的角色。 供应链对一家企业所产生的作用是巨大的、不可替代的。在完成连接企业、企业的产品、服务和顾客的整个供应链的过程中，即一个需求的“产生一满足”周期，供应链成本可能占到企业收入的一半或更多。在企业的经营战略中，供应链的主体作用不仅仅只是满足客户的需求这么简单。以战略价值的实现水平为标准，供应链的角色可以划分为五个阶段(五种状态)，最低水平的供应链仅仅停留在运作管理层面—— 成本控制。在最高的层面，要求一家企业的价值链必须能够最大限度的实现战略性的价值，包括作业成本的控制，有效的资本运筹，风险管理并且实现收益。虽然每一个角色都有截然不同的特征和内涵，但各个角色不是相互排斥的。 策略之一：稳定厂商阶段 稳定厂商是供应链上最低的战略价值贡献水平。在这个低水平的价值实现阶段，就像它和其它企业之间的供应链合作伙伴一样，外部环境对企业的影响不大。稳定厂商的角色存在于发展成熟的、变化慢的行业。例如精制食盐制造行业，供应和需求都是均衡的。由于供应和需求是确定的，就大大减少了对预测的需要。由于整个供应链是确定的，如每一个阶段要生产多少的产品是固定的，这种可预测性使得供应链对需求的变动反应不大。 流程规则、员工技能和技术重点都是为企业的长期运行而设计的，变化很少。以生产流程为例，由于规模生产，保持低成本并不需要进行有规律的过程重组，可预测性的需求使得对管理决策的要求也不高。同样，资产投资方向也非常具体明确。企业的管理费用和管理活动都可以减少到最低限度，需要对市场风险作出战略性转变的要求也不高。 策略之二：被动厂商角色 作为一个被动商，供应链角色在整个企业战略中的作用仍然很小。供应链通常通过对企业的销售和市场战略做出响应并支持，来满足需求。被动厂商的状态是非常不稳定的，若要保证高水平的服务，则需要不计成本的投入。除非一家企业在其它功能领域(例如，需求产生、生产创新等等)或者其它的价值活动(如产品领导能力和客户亲密程度)等方面明显地优于别人，否则，作为一个响应型的供应商，企业要想长期生存是极其困难的。 其它的功能部门包括供应链本身都把供应链看作是一个成本中心。尽管供应链在供应链流程整合方面，有效的主动可能会努力控制成本，通常这些努力使厂商与有效被动厂商区别不大，供应或者达不到既定的目标。各功能部门链以主动带动需求为目标，通过产品设计独立控制并且经常寻求他们自身效率的最大化或者服务改善来更进一步地提高供应链效益最大化，而以损害整个供应链系统为代价。此外，供应链各个环节了解自己对上游理趋向于把T人看作是“可代替的资产”， 和下游环节的影响，也明白带动需求的决用很少的金钱和时间投入就能够进一步地策对整个供应链活动的影响。提高作业工人的技能。很少把注意力放在有效的主动厂商适当地投资于新的技能，获取竞争的技术、资产投入，或者更改现存技术—— 集成的信息系统。允许诸如销售、采购的技术来支持最新的销售和市场需求。 采购、生产和物流不同的部门分享相同的信息并且同时共享建议和思想。 策略之三：主动厂商阶段 从稳定厂商过渡到被动厂商，供应链仍然没有被提升到竞争的战略角度，或者说，仅仅意识到它的战略意义。供应链仍然是一个满足需求的角色，而不是带动需求。然而，作为一个有效的、集成的整体，现代供应链在满足需求的同时，也是一个低成本、提供优质客户服务的整合体，且不能各自为营。 内部实现集成的供应链流程寻求的是降低最终产品的总交付成本，而不是制造部门为提高自己的效率而牺牲物流或采购部门的效率。生产线经理、管理员等等都具有并且理解绩效标准，这些标准明确了他们的行为怎么影响上游和下游的流程。他们的活动都以减少最终产品的总交付成本为准则。 很多企业把视线移向改进作业效率，而不注意资产成本方面的管理。技术的角色也发生变化。在他们降低总交付成本的努力中，很多企业把技术的获得看作是供应链的首要任务。企业抱着降低劳动成本和改进生产能力和生产量的目的，不断地在新设备和自动化系统方面进行无谓的投资。 策略之四：有效的主动厂商阶段 从被动厂商向有效的主动厂商的转变才是一场真正的变革。制造和销售、市场部门的关系从结构上发生了根本的变化。供应链完全了解它所需要努力的方向，并且销售和市场功能被供应链视作一个组成部分。供应链必须能够循序渐进、按照既定目标自我完善，从而不断提高供应链的效率。 策略之五：收入边际利润驱动的厂商阶段 收入、边际利润驱动的厂商进一步促进供应链的变革。在满足需求和需求带动方面完成企业问的整合，实现了真正的供应链整合。在供应链的发展中，供应链真正被定位为企业间的合作战略。高层的战略方针包括对供应链的积极预测。例如个人电脑行业，按订单生产的供应链模式是边际利润驱动厂商的最好例子。 新的供应链战略建立在它与外部组织的交互作用的基础之上。企业资源规划系统达到与顾客和供应商以及其他结盟伙伴的双向的、即时的数据连接。真正的“拉动式”需求信息在组织间无缝地传递，让供应合作伙伴达成一个共同的利润目标，并且完全实现预测、计划和补货程序的整合，达到提高库存透明度、连续补货、甚至共同产品设计和分享技术知识的目的。此外，收入、成本、资产回报和收益性等方面的绩效评估也被提升到供应链层面。 技术的重点将放在信息系统的发展方面。和顾客、供应商和结盟伙伴实现即时的信息通讯，无论是直接的，或者是由第三方提供的形式，它都将带来巨大的回报。 对于很多企业来说，供应链价值能够通过提升供应链的战略重要性来实现最大化。供应链必须实现从成本向价值目标观念的转变。企业领导者必须清楚这种转变的必要性。然而，仅仅是思想观念的转变是不够的，只有采取行动才能实现真正的供应链变革。组织结构、基础设施、作业流程、和管理系统不仅仅局限于企业内部的供应链，而必须与客户、供应商和结盟伙伴进行整合。","categories":[{"name":"供应链","slug":"供应链","permalink":"http://www.gistop.com/categories/供应链/"},{"name":"战略","slug":"供应链/战略","permalink":"http://www.gistop.com/categories/供应链/战略/"}],"tags":[{"name":"业务","slug":"业务","permalink":"http://www.gistop.com/tags/业务/"},{"name":"供应链管理","slug":"供应链管理","permalink":"http://www.gistop.com/tags/供应链管理/"}]},{"title":"前端全栈之路--使用Node.js与React仿微信的视频IM应用","slug":"fe-full-stack","date":"2018-08-03T11:17:26.000Z","updated":"2018-08-26T06:43:44.967Z","comments":true,"path":"2018/08/03/fe-full-stack/","link":"","permalink":"http://www.gistop.com/2018/08/03/fe-full-stack/","excerpt":"直入主题，使用一周的时间使用前端相关的技术做一个仿微信的IM应用。","text":"直入主题，使用一周的时间使用前端相关的技术做一个仿微信的IM应用。具体的效果如下：线上地址： https://chat.gismall.com/前端仓库地址：https://github.com/hsuehic/react-wechat后端仓库地址：https://github.com/hsuehic/react-wechat-backend 涉及的技术主要包括以下： React Dva Antd-Mobile NodeJS Koa WebSocket WebRTC JsonWebToken Redis MongoDB Nginx PM2 想与大的交流的点主包括以下内容： WebRTC的一些基本概念 使用Node.js与WebSocket构建WebRTC信令服务器 使用NoSQL数据存储设计与关系型数据库的差异 Node.js应用的发布和热更新 JSONWebToken在前后端分离应用及WebSocket中鉴权 欢迎大家拍砖！ 1. WebRTC的一些基本概念1.1 WebRTC相关的协议1.1.1 ICEICE, 全名 Interactive Connectivity Establishment。是一个允许浏览器之间建议交互的点对点连接的框架。点A与点B之间不能简单直接连接的原因有很多。 首先，需要穿过可能阻止连接的防火墙，其次在大多数情况下设备需要一个唯一的公有地址，另外就是路由器不允许点点对的数据直接传递。ICE使用STUN或者(和)TURN服务器解决这些问题。 1.1.2 STUNSTUN, 全名Session Traversal Utilities for NAT (STUN) 。是一个用来发现公共地址和路由对点对点直连限制的服务。客户端(浏览器)向STUN服务器发送一个请求，然后STUN服务器会返回客户端的公网地址和客户端所在路由NAT是否可用。 1.1.3 NATNAT,全名Network Address Translation (NAT) 。是一个网络地址转换协议。就是给连接到路由的设备一个私有地址，并且通路由且的公网IP使用特定端口转发使用设置在公网上可以被发现和访问。有些路由会限连接到私有网络。 1.1.4 TURNTURN全名Traversal Using Relays around NAT (TURN)。有些使用NAT的路由会使用一种被称为“对称NAT”的限制。在这种\b情况下需要有一个中继服务器分别与终端建立连接并转发数据。 1.1.5 SDPSDP全名Session Description Protocol (SDP) 。对多媒体连接的一种标准描述，如分辨率、格式、解码器、加密等，使数据传输时连接两端都了解对方。实质上，SDP是传输数据的元数据。 1.2 信令和视频呼叫WebRTC允许实时点对点的视频传输。 1.2.1 信令交互时序 1.2.2 视频请求交互时序 1.3 WebRTC主要的接口1.3.1 RTCPeerConnection表示本地设备到远端的WebRTC连接。提供了连接到远端Peer的方法，维护、监视、关闭连接等。 1.3.2 RTCConfigurationRTCPeerConnection的配置信息。 1.3.3 RTCDataChannel关连到RTCPeerConnection的通道，用来传输任意类型的数据。 2. 使用Node.js与WebSocket构建WebRTC信令服务器2.1 Koa Websock中间件需要使用koa支持websocket路由以及上下文使用。相关的middleware代码如下。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * @File : koa-websocket.js * @Author : Richard Hsueh &lt;xiaowei.hsueh@gmail.com&gt; (https://www.gistop.com/) * @Link : http://www.gistop.com/ * @Date : 2018-7-1 16:31:26 */const url = require('url');const https = require('https');const compose = require('koa-compose');const co = require('co');const ws = require('ws');const WebSocketServer = ws.Server;const debug = require('debug')('koa:websockets');function KoaWebSocketServer(app) &#123; this.app = app; this.middleware = [];&#125;KoaWebSocketServer.prototype.listen = function listen(options) &#123; this.server = new WebSocketServer(options); this.server.on('connection', this.onConnection.bind(this));&#125;;KoaWebSocketServer.prototype.onConnection = function onConnection(socket, req) &#123; debug('Connection received'); socket.on('error', err =&gt; &#123; debug('Error occurred:', err); &#125;); const fn = co.wrap(compose(this.middleware)); const context = this.app.createContext(req); context.websocket = socket; context.path = url.parse(req.url).pathname; fn(context).catch(err =&gt; &#123; debug(err); &#125;);&#125;;KoaWebSocketServer.prototype.use = function use(fn) &#123; this.middleware.push(fn); return this;&#125;;module.exports = function middleware(app, wsOptions, httpsOptions) &#123; const oldListen = app.listen; app.listen = function listen(...args) &#123; debug('Attaching server...'); if (typeof httpsOptions === 'object') &#123; const httpsServer = https.createServer(httpsOptions, app.callback()); app.server = httpsServer.listen(...args); &#125; else &#123; app.server = oldListen.apply(app, args); &#125; const options = &#123; server: app.server &#125;; if (wsOptions) &#123; Object.keys(wsOptions).forEach(key =&gt; &#123; if (Object.prototype.hasOwnProperty.call(wsOptions, key)) &#123; options[key] = wsOptions[key]; &#125; &#125;); &#125; app.ws.listen(options); return app.server; &#125;; app.ws = new KoaWebSocketServer(app); return app;&#125;; 2.2 聊天功能及信令转发实现2.2.1 信令类型定义12345678910const RTC_MESSAGE_TYPE = &#123; CANDIDATE: 'new-ice-candidate', HANG_UP: 'hang-up', VIDEO_OFFER: 'video-offer', VIDEO_ANSWER: 'video-answer', INVITE_OFFER: 'invite-offer', INVITE_ACCEPT: 'invite-accept', INVITE_REFUSE: 'invite-refuse', INVITE_CANCEL: 'invite-cancel'&#125;; 2.2.2 WebSocket路由及消息处理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950websocket.get('/wechat/:token', async(ctx, next) =&gt; &#123; const &#123; token &#125; = ctx.params; const &#123; secret &#125; = configs; const user = await verify(token, secret, &#123; ignoreExpiration: true &#125;); ctx.mongo = mongo; // 已经登录通过难 if (user) &#123; const &#123; phone &#125; = user; sockets.set(phone, ctx.websocket); await sendInitialData(ctx, user); ctx.websocket.on('message', message =&gt; &#123; try &#123; const msg = JSON.parse(message); const &#123; type &#125; = msg; const &#123; payload &#125; = msg; const &#123; to &#125; = payload; switch (type) &#123; case 'candidate': sendCandidate(ctx, user, msg); break; case 'wechat/saveMessage': sendMessage(ctx, user, msg); break; case RTC_MESSAGE_TYPE.CANDIDATE: case RTC_MESSAGE_TYPE.HANG_UP: case RTC_MESSAGE_TYPE.VIDEO_OFFER: case RTC_MESSAGE_TYPE.VIDEO_ANSWER: case RTC_MESSAGE_TYPE.INVITE_ACCEPT: case RTC_MESSAGE_TYPE.INVITE_CANCEL: case RTC_MESSAGE_TYPE.INVITE_OFFER: case RTC_MESSAGE_TYPE.INVITE_REFUSE: sendMessageToClient(to, message); break; default: break; &#125; &#125; catch (e) &#123; console.error(e); &#125; &#125;); ctx.websocket.on('close', () =&gt; &#123; sockets.delete(phone); &#125;); &#125; else &#123; // 未登录的情况直接关闭socket链接 ctx.websocket.close(); &#125; await next();&#125;); 2.2.3 离线消息处理12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 保存离线消息 * @param &#123;object&#125; ctx 上下文 * @param &#123;object&#125; user 当前会话用户 * @param &#123;object&#125; msg 消息对象 */const saveOfflineMessage = async(ctx, user, msg) =&gt; &#123; const now = new Date(); const &#123; payload &#125; = msg; const &#123; to, content, from, timestamp &#125; = payload; const &#123; phone &#125; = user; const conversationModel = new ConversationModel(ctx); const selector = &#123; phone: to &#125;; const prefix = `conversation.$&#123;phone&#125;`; const document = &#123; $set: &#123; [`$&#123;prefix&#125;.timestamp`]: now.getTime() &#125;, $inc: &#123; [`$&#123;prefix&#125;.newCount`]: 1 &#125;, $addToSet: &#123; [`$&#123;prefix&#125;.items`]: &#123; content, to, from, timestamp &#125; &#125; &#125;; const options = &#123; upsert: true &#125;; const p = conversationModel.update(selector, document, options); p.then(() =&gt; &#123; console.log('保存离线消息成功！'); &#125;).catch(error =&gt; &#123; console.log('保存离线消息失败！'); console.error(error); &#125;);&#125;; 2.2.4 初始化数据主要包括联系人信息和离线会话1234567891011121314151617181920212223/** * 发送初始化数据 * @param &#123;Application&#125; ctx 上下文对象 */const sendInitialData = async(ctx, user) =&gt; &#123; const userModel = new UserModel(ctx, user); const conversations = await userModel.getConversationList(); if (conversations) &#123; ctx.websocket.send(JSON.stringify(&#123; type: 'wechat/saveConversation', payload: &#123; conversations &#125; &#125;)); &#125; const contacts = await userModel.getContactList(); ctx.websocket.send(JSON.stringify(&#123; type: 'wechat/save', payload: &#123; contacts &#125; &#125;));&#125;; 3. 使用NoSQL数据存储设计与关系型数据库的差异 IM应用中需要存储类似于用户、联系人、对话、对话内容、联系人设置等信息 在以前使用关系型型数据库时代，我们可能会根据范式思想使用不少映射表来存类似于朋友、对话、备注、设置等信息，在二维的信息中表示关系可能会很复杂，为检索性能需要小心的设置索引，查询时也需要做很多的连接查询。 在NoSQL时代，MongoDB等非关系型数据库，支持以Document的形式存储数据，可以很方便的以JSON节点的形式表示对象之的关系，也支持复杂、功能丰富的子节点检索功能，在数据结构的设计方面比RDB有很大的优势。比事以下是一个聊天信息的数据结构。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/* 3 */&#123; \"_id\" : ObjectId(\"5b483da404739f15a38387ed\"), \"phone\" : \"18958067915\", \"conversation\" : &#123; \"18958067917\" : &#123; \"items\" : [ \"你好！\", &#123; \"content\" : \"fdfdfd\", \"to\" : \"18958067915\", \"from\" : \"18958067917\", \"timestamp\" : 1533300341213.0 &#125;, &#123; \"content\" : \"fjdlfjd;\", \"to\" : \"18958067915\", \"from\" : \"18958067917\", \"timestamp\" : 1533300342076.0 &#125;, &#123; \"content\" : \"fdjfldjf\", \"to\" : \"18958067915\", \"from\" : \"18958067917\", \"timestamp\" : 1533300342933.0 &#125;, &#123; \"content\" : \"fjdkj;\", \"to\" : \"18958067915\", \"from\" : \"18958067917\", \"timestamp\" : 1533300343925.0 &#125;, &#123; \"content\" : null, \"to\" : \"18958067915\", \"from\" : \"18958067917\", \"timestamp\" : 1533300344110.0 &#125; ], \"timestamp\" : 1533300344110.0, \"newCount\" : 6.0 &#125;, \"18958067916\" : &#123; \"items\" : [ \"你好！\" ], \"timestamp\" : 1531460398135.0, \"newCount\" : 1.0 &#125; &#125;&#125; 后面有时间再针对这个IM应用的数据结构设计展开介绍。 4. Node.js应用的发布和热更新先贴上代码(deploy.sh)。123456789101112131415161718192021222324252627282930313233#!/bin/sh# Author : Richard# Copyright (c) Tutorialspoint.com# Script follows here:# Reference: https://www.tutorialspoint.com/unix/unix-file-management.htmecho upload files to the serverecho copy scriptshost=www.gismall.comroot=/root/apps/wechatdistination=root@$host:$rootscp -r ./bin $distinationscp -r ./controllers $distinationscp -r ./middlewares $distinationscp -r ./models $distinationscp -r ./routes $distinationscp -r ./services $distinationscp -r ./utils $distinationscp -r ./views $distinationscp app.js $distinationscp configs.js $distinationscp package-lock.json $distinationscp package.json $distinationscp README.md $distinationscp yarn.lock $distinationssh root@$host &lt;&lt; remotessh cd $root npm install pm2 restart wechat exitremotessh 以上代码只是我发布我服务器端应用的代码。更新发布时只要执行以下代码就行了。1./deploy.sh 更新只是合适pm2直拉重启，很low的方法与Node.js的热更新无关。下面再谈谈我了解的Node.js应用热更新。 5. JSONWebToken在前后端分离应用及WebSocket中鉴权 JSON Web Token (JWT) is a compact, URL-safe means of representing claims to be transferred between two parties. The claims in a JWT are encoded as a JSON object that is used as the payload of a JSON Web Signature (JWS) structure or as the plaintext of a JSON Web Encryption (JWE) structure, enabling the claims to be digitally signed or integrity protected with a Message Authentication Code (MAC) and/or encrypted. 以上是JSONWebToken的定义 5.1 Json Web Token是干什么 简称JWT，在HTTP通信过程中，进行身份认证。 我们知道HTTP通信是无状态的，因此客户端的请求到了服务端处理完之后是无法返回给原来的客户端。因此需要对访问的客户端进行识别，常用的做法是通过session机制：客户端在服务端登陆成功之后，服务端会生成一个sessionID，返回给客户端，客户端将sessionID保存到cookie中，再次发起请求的时候，携带cookie中的sessionID到服务端，服务端会缓存该session（会话），当客户端请求到来的时候，服务端就知道是哪个用户的请求，并将处理的结果返回给客户端，完成通信。 通过上面的分析，可以知道session存在以下问题： 1. session保存在服务端，当客户访问量增加时，服务端就需要存储大量的session会话，对服务器有很大的考验； 2. 当服务端为集群时，用户登陆其中一台服务器，会将session保存到该服务器的内存中，但是当用户的访问到其他服务器时，会无法访问，通常采用缓存一致性技术来保证可以共享，或者采用第三方缓存来保存session，不方便。 5.2 Json Web Token是怎么做的1. 客户端通过用户名和密码登录服务器； 2. 服务端对客户端身份进行验证； 3. 服务端对该用户生成Token，返回给客户端； 4. 客户端将Token保存到本地浏览器，一般保存到cookie中； 5. 客户端发起请求，需要携带该Token； 6. 服务端收到请求后，首先验证Token，之后返回数据。 - 服务端不需要保存Token，只需要对Token中携带的信息进行验证即可； - 无论客户端访问后台的那台服务器，只要可以通过用户信息的验证即可。 5.3 WebSocket 连时通过 JSON Web Token 鉴权这一块我没有找到什么好的方法实现。我目前的实现方法是在websocket连接的路由中加上token, 服务器端在接到连接请求时，判断token是否有效，如有效则发送相应的数据并保存连接，如token无效则关闭连接。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gistop.com/categories/JavaScript/"},{"name":"Performance","slug":"JavaScript/Performance","permalink":"http://www.gistop.com/categories/JavaScript/Performance/"}],"tags":[{"name":"WebRTC","slug":"WebRTC","permalink":"http://www.gistop.com/tags/WebRTC/"},{"name":"全栈","slug":"全栈","permalink":"http://www.gistop.com/tags/全栈/"}]},{"title":"手把手教你用React和NodeJS开发一个仿微信的IM应用（一）","slug":"fake-wechat","date":"2018-07-08T11:27:43.000Z","updated":"2018-08-26T06:43:44.967Z","comments":true,"path":"2018/07/08/fake-wechat/","link":"","permalink":"http://www.gistop.com/2018/07/08/fake-wechat/","excerpt":"计划在团队内部做一个使用webrtc做实时音视频聊天实现的分享。既然是分享，就得有App演示和提供现场体验吧。要给别人看，界面总得做一个吧？ 没有UX, 因此，想到了直接Fake一个Webchat用户界面： 一是个人非常喜欢微信界面，设计得很简单，易用，组件抽象得很好，实现也相对简单。二是刚好可以练习下h5开发。到厂内后，只参与了一个toC的互动和几个toB的小移动项目的开发，这次刚好可学习下。 刚开始API想部分调用web.wechat的API减少工作量，抓包看了下还是挺复杂的，因此，还是决定自己写反正也需要写信令服务器，刚好可以一起。","text":"计划在团队内部做一个使用webrtc做实时音视频聊天实现的分享。既然是分享，就得有App演示和提供现场体验吧。要给别人看，界面总得做一个吧？ 没有UX, 因此，想到了直接Fake一个Webchat用户界面： 一是个人非常喜欢微信界面，设计得很简单，易用，组件抽象得很好，实现也相对简单。二是刚好可以练习下h5开发。到厂内后，只参与了一个toC的互动和几个toB的小移动项目的开发，这次刚好可学习下。 刚开始API想部分调用web.wechat的API减少工作量，抓包看了下还是挺复杂的，因此，还是决定自己写反正也需要写信令服务器，刚好可以一起。 标题有些夸张， 原预计一周左右能仿一个具体微信基本功能的IM应用出来。但实际开发过程，花了三个多周末了，才完成80%左右。 应用的效果如下。 应用开发过程中，欢迎一起玩耍，欢迎 Fork, PR, Start。 前端仓库：hsuehic/react-wechat 后端他库：hsuehic/react-wechat-backend demo地址： https://chat.gismall.com 手机浏览器扫一扫： 大致效果如果下： 涉及到的主要技术栈包括： React Dva Antd-Mobile NodeJS Koa WebSocket WebRTC JsonWebToken Redis MongoDB Nginx PM2 PWA 后面大致会按照以下方面来介绍整个过程。 缘起 计划 选型 3.1 react、dva、antd-mobile 3.2 koa 3.3 redis、 mongodb 3.4 websocket、WebRTC 开发 4.1 UI组件开发 4.2 路由及业务逻辑 4.3 http服务 4.4 WebSocket 服务 4.5 WebRTC p2p 4.6 安全 4.6.1 信息存储安全 4.6.2 信息传输安全 4.6.3 防攻击 4.7 性能 前端性能优化 后端性能优化、服务器配置优化 发布 5.1 静态资源 Nginx 5.2 后台服务 PM2, Nginx Proxy 5.3 稳定性 Cluster &amp;&amp; Load Balance","categories":[{"name":"Web","slug":"Web","permalink":"http://www.gistop.com/categories/Web/"},{"name":"Web Application","slug":"Web/Web-Application","permalink":"http://www.gistop.com/categories/Web/Web-Application/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://www.gistop.com/tags/Web/"},{"name":"NodeJS","slug":"NodeJS","permalink":"http://www.gistop.com/tags/NodeJS/"},{"name":"React","slug":"React","permalink":"http://www.gistop.com/tags/React/"},{"name":"Antd-mobile","slug":"Antd-mobile","permalink":"http://www.gistop.com/tags/Antd-mobile/"},{"name":"WebRTC","slug":"WebRTC","permalink":"http://www.gistop.com/tags/WebRTC/"},{"name":"WebSocket","slug":"WebSocket","permalink":"http://www.gistop.com/tags/WebSocket/"},{"name":"PWA","slug":"PWA","permalink":"http://www.gistop.com/tags/PWA/"}]},{"title":"SSL介绍及Nginx Https配置","slug":"ssl-and-nginx-https","date":"2018-07-08T11:18:34.000Z","updated":"2018-08-26T06:43:44.973Z","comments":true,"path":"2018/07/08/ssl-and-nginx-https/","link":"","permalink":"http://www.gistop.com/2018/07/08/ssl-and-nginx-https/","excerpt":"现在大多数站点都使用了https协议，iOS应用也强制使用https连，https也是应用数据安全的需要。本文主要记录自己对SSL的了解，以及Nginx 中配置https的方法。","text":"现在大多数站点都使用了https协议，iOS应用也强制使用https连，https也是应用数据安全的需要。本文主要记录自己对SSL的了解，以及Nginx 中配置https的方法。 SSL介绍SSL(Secure Sockets Layer 安全套接层),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密。 SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。SSL协议可分为两层： SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。 SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。 SSL提供以下能力 认证用户和服务器，确保数据发送到正确的客户机和服务器； 加密数据以防止数据中途被窃取； 维护数据的完整性，确保数据在传输过程中不被改变。 SSL工作流程 服务器认证阶段：1）客户端向服务器发送一个开始信息“Hello”以便开始一个新的会话连接；2）服务器根据客户的信息确定是否需要生成新的主密钥，如需要则服务器在响应客户的“Hello”信息时将包含生成主密钥所需的信息；3）客户根据收到的服务器响应信息，产生一个主密钥，并用服务器的公开密钥加密后传给服务器；4）服务器回复该主密钥，并返回给客户一个用主密钥认证的信息，以此让客户认证服务器。 用户认证阶段：在此之前，服务器已经通过了客户认证，这一阶段主要完成对客户的认证。经认证的服务器发送一个提问给客户，客户则返回（数字）签名后的提问和其公开密钥，从而向服务器提供认证。 SSL提供的安全通道具有以下特性： 机密性：SSL协议使用密钥加密通信数据。 可靠性：服务器和客户都会被认证，客户的认证是可选的。 完整性：SSL协议会对传送的数据进行完整性检查。 从SSL 协议所提供的服务及其工作流程可以看出，SSL协议运行的基础是商家对消费者信息保密的承诺，这就有利于商家而不利于消费者。在电子商务初级阶段，由于运作电子商务的企业大多是信誉较高的大公司，因此这问题还没有充分暴露出来。但随着电子商务的发展，各中小型公司也参与进来，这样在电子支付过程中的单一认证问题就越来越突出。虽然在SSL3.0中通过数字签名和数字证书可实现浏览器和Web服务器双方的身份验证，但是SSL协议仍存在一些问题，比如，只能提供交易中客户与服务器间的双方认证，在涉及多方的电子交易中，SSL协议并不能协调各方间的安全传输和信任关系。在这种情况下，Visa和 MasterCard两大信用卡公组织制定了SET协议，为网上信用卡支付提供了全球性的标准。 SSL体系结构SSL的体系结构中包含两个协议子层，其中底层是SSL记录协议层（SSL Record Protocol Layer）；高层是SSL握手协议层（SSL HandShake Protocol Layer）。 SSL记录协议层的作用是为高层协议提供基本的安全服务。SSL纪录协议针对HTTP协议进行了特别的设计，使得超文本的传输协议HTTP能够在SSL运行。纪录封装各种高层协议，具体实施压缩解压缩、加密解密、计算和校验MAC等与安全有关的操作。SSL握手协议层包括SSL握手协议（SSL HandShake Protocol）、SSL密码参数修改协议（SSL Change Cipher Spec Protocol）、应用数据协议（Application Data Protocol）和SSL告警协议（SSL Alert Protocol）。握手层的这些协议用于SSL管理信息的交换，允许应用协议传送数据之间相互验证，协商加密算法和生成密钥等。SSL握手协议的作用是协调客户和服务器的状态，使双方能够达到状态的同步。 SSL记录协议SSL记录协议（Record Protocol）为SSL连提供两种服务。 保密性：利用握手协议所定义的共享密钥对SSL净荷（Payload）加密。 完整性：利用握手协议所定义的共享的MAC密钥来生成报文的鉴别码（MAC）。SSL的工作过程如下。发送方的工作过程为： 从上层接受要发送的数据（包括各种消息和数据）； 对信息进行分段，分成若干纪录； 使用指定的压缩算法进行数据压缩（可选）； 使用指定的MAC算法生成MAC； 使用指定的加密算法进行数据加密； 添加SSL记录协议的头，发送数据。接收方的工作过程为： 接收数据，从SSL记录协议的头中获取相关信息； 使用指定的解密算法解密数据； 使用指定的MAC算法校验MAC； 使用压缩算法对数据解压缩（在需要进行）； 将记录进行数据重组； 将数据发送给高层。SSL记录协议处理的最后一个步骤是附加一个SSL记录协议的头，以便构成一个SSL记录。SSL记录协议头中包含了SSL记录协议的若干控制信息。 SSL的会话状态会话（Session）和连接（Connection）是SSL中两个重要的概念，在规范中定义如下。（1）SSL连接：用于提供某种类型的服务数据的传输，是一种点对点的关系。一般来说，连接的维持时间比较短暂，并且每个连接一定与某一个会话相关联。（2）SSL会话：是指客户和服务器之间的一个关联关系。会话通过握手协议来创建。它定义了一组安全参数。一次会话过程通常会发起多个SSL连接来完成任务，例如一次网站的访问可能需要多个HTTP/SSL/TCP连接来下载其中的多个页面，这些连接共享会话定义的安全参数。这种共享方式可以避免为每个SSL连接单独进行安全参数的协商，而只需在会话建立时进行一次协商，提高了效率。每一个会话（或连接）都存在一组与之相对应的状态，会话（或连接）的状态表现为一组与其相关的参数集合，最主要的内容是与会话（或连接）相关的安全参数的集合，用会话（或连接）中的加密解密、认证等安全功能的实现。在SSL通信过程中，通信算法的状态通过SSL握手协议实现同步。根据SSL协议的约定，会话状态由以下参数来定义：（1）会话标识符：是由服务器选择的任意字节序列，用于标识活动的会话或可恢复的会话状态。（2）对方的证书：会话对方的X.509v3证书。该参数可为空。（3）压缩算法：在加密之前用来压缩数据的算法。（4）加密规约（Cipher Spec）：用于说明对大块数据进行加密采用的算法，以及计算MAC所采用的散列算法。（5）主密值：一个48字节长的秘密值，由客户和服务器共享。（6）可重新开始的标识：用于指示会话是否可以用于初始化新的连接。连接状态由以下参数来定义：（1）服务器和客户器的随机数：是服务器和客户为每个连接选择的用于标识连接的字节序列。（2）服务器写MAC密值：服务器发送数据时，生成MAC使用的密钥，长度为128 bit。（3）客户写MAC密值，服务器发送数据时，用于数据加密的密钥，长度为128 bit 。（4）客户写密钥：客户发送数据时，用于数据加密的密钥，长度为128 bit。（5）初始化向量：当使用CBC模式的分组密文算法是=时，需要为每个密钥维护初始化向量。（6）序列号：通信的每一端都为每个连接中的发送和接收报文维持着一个序列号。 HTTPS介绍HTTPS（Hypertext Transfer Protocol Secure）安全超文本传输协议它是由Netscape开发并内置于其浏览器中，用于对数据进行压缩和解压操作，并返回网络上传送回的结果。HTTPS实际上应用了Netscape的安全套接字层（SSL）作为HTTP应用层的子层。（HTTPS使用端口443，而不是象HTTP那样使用端口80来和TCP/IP进行通信。）SSL使用40 位关键字作为RC4流加密算法，这对于商业信息的加密是合适的。HTTPS和SSL支持使用X.509数字认证，如果需要的话用户可以确认发送者是谁。https是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，https的安全基础是SSL，因此加密的详细内容请看SSL。它是一个URI scheme(抽象标识符体系)，句法类同http:体系。用于安全的HTTP数据传输。https:URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。这个系统的最初研发由网景公司进行，提供了身份验证与加密通讯方法，它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。限制它的安全保护依赖浏览器的正确实现以及服务器软件、实际加密算法的支持.一种常见的误解是“银行用户在线使用https:就能充分彻底保障他们的银行卡号不被偷窃。”实际上，与服务器的加密连接中能保护银行卡号的部分，只有用户到服务器之间的连接及服务器自身。并不能绝对确保服务器自己是安全的，这点甚至已被攻击者利用，常见例子是模仿银行域名的钓鱼攻击。少数罕见攻击在网站传输客户数据时发生，攻击者尝试窃听数据于传输中。商业网站被人们期望迅速尽早引入新的特殊处理程序到金融网关，仅保留传输码(transaction number)。不过他们常常存储银行卡号在同一个数据库里。那些数据库和服务器少数情况有可能被未授权用户攻击和损害。 SSL证书自制证书第三方机构签发证书Nginx中配置","categories":[{"name":"Web","slug":"Web","permalink":"http://www.gistop.com/categories/Web/"},{"name":"Web Server","slug":"Web/Web-Server","permalink":"http://www.gistop.com/categories/Web/Web-Server/"},{"name":"Security","slug":"Web/Web-Server/Security","permalink":"http://www.gistop.com/categories/Web/Web-Server/Security/"}],"tags":[{"name":"SSL","slug":"SSL","permalink":"http://www.gistop.com/tags/SSL/"},{"name":"Nginx","slug":"Nginx","permalink":"http://www.gistop.com/tags/Nginx/"},{"name":"HTTPS","slug":"HTTPS","permalink":"http://www.gistop.com/tags/HTTPS/"}]},{"title":"React高阶组件和Context API","slug":"react-hoc-context-api","date":"2018-07-08T11:14:21.000Z","updated":"2018-08-26T06:43:44.972Z","comments":true,"path":"2018/07/08/react-hoc-context-api/","link":"","permalink":"http://www.gistop.com/2018/07/08/react-hoc-context-api/","excerpt":"社区中介绍React HOC 和 Context API的分享和文章非常多，但将两者结合起来使用的介绍比较少，个人觉得将两都结合起来应用到我们的设计中，往往会使我们的设计更加的合理。","text":"社区中介绍React HOC 和 Context API的分享和文章非常多，但将两者结合起来使用的介绍比较少，个人觉得将两都结合起来应用到我们的设计中，往往会使我们的设计更加的合理。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gistop.com/categories/JavaScript/"},{"name":"React","slug":"JavaScript/React","permalink":"http://www.gistop.com/categories/JavaScript/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://www.gistop.com/tags/React/"},{"name":"HOC","slug":"HOC","permalink":"http://www.gistop.com/tags/HOC/"},{"name":"Context API","slug":"Context-API","permalink":"http://www.gistop.com/tags/Context-API/"}]},{"title":"React Context 使用","slug":"react-context-privider","date":"2018-06-21T15:17:22.000Z","updated":"2018-08-26T06:43:44.971Z","comments":true,"path":"2018/06/21/react-context-privider/","link":"","permalink":"http://www.gistop.com/2018/06/21/react-context-privider/","excerpt":"Context 提代了一个向整个组件树传递数据的方法，而不需要通过属性向下一层一层的手动传递。 在一个典型的React应用中， 数据从父组件到子组件通过属性传递，这种方法对于某些特定的在应用中许多组件都需要的属性（比如，locale引用，UI主题等）来说可能会显得比较笨重。 Context提供了一个组件间共享值的方法，而不需要明确的向整个树的每一层都传递一个属性。","text":"Context 提代了一个向整个组件树传递数据的方法，而不需要通过属性向下一层一层的手动传递。 在一个典型的React应用中， 数据从父组件到子组件通过属性传递，这种方法对于某些特定的在应用中许多组件都需要的属性（比如，locale引用，UI主题等）来说可能会显得比较笨重。 Context提供了一个组件间共享值的方法，而不需要明确的向整个树的每一层都传递一个属性。 1. 什么时候使用2. API2.1 React.createContext2.2 Privider2.3 Consumer3. 示例3.1 Dynamic Context3.2 Updating Context from a Nested Component3.3 Accessing Context in Lifecycle Method3.4 Consuming Context with a HOC3.5 Forwarding Refs to Context Consumers4. 需要注意的地方","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gistop.com/categories/JavaScript/"},{"name":"React","slug":"JavaScript/React","permalink":"http://www.gistop.com/categories/JavaScript/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://www.gistop.com/tags/React/"},{"name":"Context","slug":"Context","permalink":"http://www.gistop.com/tags/Context/"},{"name":"Provider","slug":"Provider","permalink":"http://www.gistop.com/tags/Provider/"}]},{"title":"前端监控","slug":"fe-monitor","date":"2018-05-28T15:17:22.000Z","updated":"2018-08-26T06:43:44.968Z","comments":true,"path":"2018/05/28/fe-monitor/","link":"","permalink":"http://www.gistop.com/2018/05/28/fe-monitor/","excerpt":"优化、升级、新产品发布效果怎么样，怎么评价，性能指标、业务指标的监控。","text":"优化、升级、新产品发布效果怎么样，怎么评价，性能指标、业务指标的监控。 1 主要的技术指标1.1 每个关键环节耗时1.2 JS错误率1.3 接口成功率及接口平均耗时2 业务指标2.1 暴光率2.2 停留时长2.3 转化率监控方法和优化建议","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gistop.com/categories/JavaScript/"},{"name":"Performance","slug":"JavaScript/Performance","permalink":"http://www.gistop.com/categories/JavaScript/Performance/"}],"tags":[{"name":"性能指标","slug":"性能指标","permalink":"http://www.gistop.com/tags/性能指标/"},{"name":"业务指标","slug":"业务指标","permalink":"http://www.gistop.com/tags/业务指标/"}]},{"title":"React v16 的新特性 (一) React 16.0.0","slug":"react-16-new-features","date":"2018-05-28T15:17:22.000Z","updated":"2018-08-26T06:43:44.971Z","comments":true,"path":"2018/05/28/react-16-new-features/","link":"","permalink":"http://www.gistop.com/2018/05/28/react-16-new-features/","excerpt":"这一年都每天忙着业务， 也没有时间看社区的新内容。前几天（2018/05/23）React发布了16.4.0，才发现自己好久没有关注相关的内容了，正好找时间看下16.0.0版本以来的新特性。16.0.0 版本主要更新包括以下几方面： 新的JavaScript运行环境依赖 新特性 组件render方法可以返回数组和字符串 优化了错误处理， 增加了错误边界组件 （Error Boundaries) 增加了ReactDOM.createPortal方法支持将子Dom树直接渲染到其它的DOM 流模式的SSR React DOM 允许非标准的属性 不兼容的改变 移除的废弃内容","text":"这一年都每天忙着业务， 也没有时间看社区的新内容。前几天（2018/05/23）React发布了16.4.0，才发现自己好久没有关注相关的内容了，正好找时间看下16.0.0版本以来的新特性。16.0.0 版本主要更新包括以下几方面： 新的JavaScript运行环境依赖 新特性 组件render方法可以返回数组和字符串 优化了错误处理， 增加了错误边界组件 （Error Boundaries) 增加了ReactDOM.createPortal方法支持将子Dom树直接渲染到其它的DOM 流模式的SSR React DOM 允许非标准的属性 不兼容的改变 移除的废弃内容 新的JavaScript运行环境依赖React 16依赖集合类型Map和Set,还有requestAnimationFrame, 如果需要兼容老的不原生支持这些特性的浏览器和设备，需要引入相应的polyfill。 使用core-js polyfilled环境支持老浏览器的示例如下。 12345678910import 'core-js/es6/map';import 'core-js/es6/set';import React from 'react';import ReactDOM from 'react-dom';ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById('root')); 使用raf 包来的shim requestAnimationFrame示例1import 'raf/polyfill'; 下面顺便温故下相关的内容。 MapMap对象保存键值对，任何值，对象或原始值都可以作为一个键或一个值。键的比较基于”SameValueZero”算法: NaN 与NaN相同，虽然 （NaN !== NaN),剩余所有其它值都是按按===运算结果判断是否相等。 与Obejct对象比较Object和Map类似的是，都允许按键存取一个值 、删除键、检测一个键是否绑定了值。因此，过去一直把对象当成Map使用，当然也没有其它内建的替代方法。不过， Map和Object有一些重要的区别，在以下情况，Map会是更好的选择。 一个对象的键只能是字符串或者Symbols, 但一个Map的键可以是任意值，包括函数、对象、基本类型。 可以通过size属性直接获取一个Map的键值对个数，而Object的键值对个数只能手动计算。 Map 是可迭代的， 而Object的迭代需要先获取它的键数组然后再进行迭代。 Obeject都有自己的原型， 所以原型链上的键名可能和对象上的键名产生冲突。虽然ES5开始可以用map = Object.create(null)来创建一个没有原型的对象，但是这种方法不常见。 Map在涉及频繁增删键值对的场景下会有些性能优化。 原型属性 Map.prototype.constructor 默认为Map函数 Map.prototype.size 原型方法 Map.prototype.clear Map.prototype.delete(key) Map.prototype.entries() Map.prototype.forEach(callbackFn[, thisArg])callbackFn(key, value) Map.prototype.get(key) Map.prototype.has(key) Map.prototype.keys() Map.prototype.set(key, value) Map.prototype.values() Map.prototype[@@iterator] 兼容性 桌面浏览器 移动浏览器 SetSet对象允许存储任意类型的唯一值，无论是原始值还是引用值。NaN和Undefined可以被存储在Set中， NaN之间被视为相同的值。 构造函数1new Set([Iterable]) 原型属性 Set.prototype.constructor默认为 Set Set.prototype.size默认为 0 原型方法 Set.prototype.add(value) Set.prototype.clear() Set.prototype.delete(value) Set.prototype.entries() Set.prototype.forEach(callbackFn[, thisArg]) Set.prototype.has(value) Set.prototype.values() Set.prototype[@@iterator] 浏览器兼容性 window.requestAnimationFramerequestAnimationFrame方法请求浏览器在下一次重绘之前调用指定的函数来更新动画。 该方法使用一个回调函数作为参数，这个回调函数会在游览器重绘前调用。回调的次数通常是每秒60次， 但大多数浏览器通常匹配W3C所建议的刷新频率。 在大多数浏览器里当运行在后台标签页或者隐藏的里时， requestAnimationFrame()会暂停调用以提升性能和电池寿命。 回调函数会被传入一个参数。 DOMHighResTimeStamp, 指示当前被requestAnimationFrame()排序的回调函数被触发的时间。即使每个回调函数的工作量计算都花了时间， 单个帧中的多个回调也都将被传入相同的时间戳。该时间戳是一个十进制数，单位毫秒， 最小精度为1ms. 浏览器兼容性 桌面浏览器 移动浏览器 新特性组件render方法可以返回数组和字符串在以前一个组件render方法返回的根元素只能有一个。如需要返回多个同级元素，需要在外层包一个节点，这样就增加了DOM的层级数，支持数组后，就不存在这个问题了。 优化了错误处理， 增加了错误边界组件 （Error Boundaries)以往， 组件中的JavaScript 错误改变React内部状态，可能会在下次渲染过程中导致不可意料的错误。这睦错误通常是由于应用代码中更早的错误导致的，但是React没有提供一个优雅的方法来处理这些错误，也没有恢复的方法。 部分UI中的JavaScript错误不应该中断整个应用。为了帮助React用户解决这个总是， React 16 引进了一个新的概念“error boundary”. 错误边界组件捕获子组件树中任意位置的JavaScript错误， 记录日志，并显示一个后备的用户界面，而不是导致整个组件树崩溃。 错误边界组件捕获整个组件树的渲染，生命周期方法，和构造函数中的错误。 如果一个组件定义了一个名为componentDidCatch(error, info)的生命周期方法，它就成为了一个错误边界组件： 123456789101112131415161718192021class ErrorBoundary extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; hasError: false &#125;; &#125; componentDidCatch(error, info) &#123; // Display fallback UI this.setState(&#123; hasError: true &#125;); // You can also log the error to an error reporting service logErrorToMyService(error, info); &#125; render() &#123; if (this.state.hasError) &#123; // You can render any custom fallback UI return &lt;h1&gt;Something went wrong.&lt;/h1&gt;; &#125; return this.props.children; &#125;&#125; 可以像其它组件一样使用错误边界组件：123&lt;ErrorBoundary&gt; &lt;MyWidget /&gt;&lt;/ErrorBoundary&gt; 增加了ReactDOM.createPortal方法支持将子Dom树直接渲染到其它的DOMPortals提供了一个最优的方法来渲染子组件到父DOM节点以外的DOM节点。1ReactDOM.createPortal(child, container) 通常在一个组件 的render方法中返回一个元素， 这个元素会被挂载到最近的父节点。12345678render() &#123; // React mounts a new div and renders the children into it return ( &lt;div&gt; &#123;this.props.children&#125; &lt;/div&gt; );&#125; 然而，有的时候把一个子节点插入到DOM中不同的地方非常有用：12345678render() &#123; // React does *not* create a new div. It renders the children into `domNode`. // `domNode` is any valid DOM node, regardless of its location in the DOM. return ReactDOM.createPortal( this.props.children, domNode );&#125; 一个很典型的场景就是，当父组件有overflow: hidden 或者z-index样式 ，但是你需要子组件在超出容器外可见。 例如， 对话框， 弹出卡片， tooltips。 Portals事件冒泡 一个Portal组件内部事件会传递整个容器的组件树，虽然那些元素在DOM树中不是祖先元素。 流模式的SSRReact DOM 允许非标准的属性不兼容的改变移除的废弃内容","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gistop.com/categories/JavaScript/"},{"name":"React","slug":"JavaScript/React","permalink":"http://www.gistop.com/categories/JavaScript/React/"}],"tags":[{"name":"React 16","slug":"React-16","permalink":"http://www.gistop.com/tags/React-16/"},{"name":"ErrorBoundary","slug":"ErrorBoundary","permalink":"http://www.gistop.com/tags/ErrorBoundary/"},{"name":"React.unstable_Profiler","slug":"React-unstable-Profiler","permalink":"http://www.gistop.com/tags/React-unstable-Profiler/"},{"name":"Map","slug":"Map","permalink":"http://www.gistop.com/tags/Map/"},{"name":"Set","slug":"Set","permalink":"http://www.gistop.com/tags/Set/"},{"name":"requestAnimationFrame","slug":"requestAnimationFrame","permalink":"http://www.gistop.com/tags/requestAnimationFrame/"}]},{"title":"健康检测和优雅关闭","slug":"node-express-health-checks","date":"2018-05-12T07:16:23.000Z","updated":"2018-08-26T06:43:44.969Z","comments":true,"path":"2018/05/12/node-express-health-checks/","link":"","permalink":"http://www.gistop.com/2018/05/12/node-express-health-checks/","excerpt":"优雅关闭你需要部署一个新版本应用时，你需要替换原来的版本。 你使用的进程管理器首先会发一个通知应用它将被关闭的SIGTERM的信号到应用。一旦应用接收到这个信号，它将停止接收新到请求，完成所有的正在执行的请求，清除它使用的资源，包括关闭数据库链接以及释放文件锁。","text":"优雅关闭你需要部署一个新版本应用时，你需要替换原来的版本。 你使用的进程管理器首先会发一个通知应用它将被关闭的SIGTERM的信号到应用。一旦应用接收到这个信号，它将停止接收新到请求，完成所有的正在执行的请求，清除它使用的资源，包括关闭数据库链接以及释放文件锁。 健康检测负载均衡使用健康检查来判断一个应用实例是否健康，能否接收和处理请求。 例如， Kubernetes具有两项健康检测： liveness. 判断 是否需要重启一个容器。 readiness. 判断 一个容器是否准备好了接收流量。 当产品不可用时， 它将被从负载均衡中移除。 第三方解决方案：terminusTerminus是一个开源的健康检测和优雅关闭的产品， 消除重复编写模版代码的需求。只需要提供优雅关闭清除逻辑和健康检测逻辑实现，terminus将会完成剩余的事情。 使用如下方式安装:1npm i @godaddy/terminus --save 下面示例展示了如果使用terminus. 更多信息， 请参考 https://github.com/godaddy/terminus。 12345678910111213141516171819202122232425262728293031const http = require('http');const express = require('express');const terminus = require('@godaddy/terminus');const app = express();app.get('/', (req, res) =&gt; &#123; res.send('ok');&#125;);const server = http.createServer(app);function onSignal() &#123; console.log('server is starting cleanup'); // start cleanup of resource, like databases or file descriptors&#125;async function onHealthCheck() &#123; // checks if the system is healthy, like the db connection is live // resolves, if health, rejects if not&#125;terminus(server, &#123; signal: 'SIGINT', healthChecks: &#123; '/healthcheck': onHealthCheck, &#125;, onSignal&#125;);server.listen(3000);","categories":[{"name":"node.js","slug":"node-js","permalink":"http://www.gistop.com/categories/node-js/"},{"name":"express","slug":"node-js/express","permalink":"http://www.gistop.com/categories/node-js/express/"}],"tags":[{"name":"health checks","slug":"health-checks","permalink":"http://www.gistop.com/tags/health-checks/"},{"name":"grace shutdown","slug":"grace-shutdown","permalink":"http://www.gistop.com/tags/grace-shutdown/"},{"name":"terminus","slug":"terminus","permalink":"http://www.gistop.com/tags/terminus/"}]},{"title":"Express应用生产环境最佳实践：性能和可靠性","slug":"node-express-performance-reliability-best-practice","date":"2018-05-12T06:20:42.000Z","updated":"2018-08-26T06:43:44.969Z","comments":true,"path":"2018/05/12/node-express-performance-reliability-best-practice/","link":"","permalink":"http://www.gistop.com/2018/05/12/node-express-performance-reliability-best-practice/","excerpt":"概览文章讨论Express应用的在生产环境的性能和可靠性的最佳实践。 这个话题很容易的联想到“devops”的世界， 包括传统的开发和运维。 自然的，下面的内容也分成两大块。","text":"概览文章讨论Express应用的在生产环境的性能和可靠性的最佳实践。 这个话题很容易的联想到“devops”的世界， 包括传统的开发和运维。 自然的，下面的内容也分成两大块。 在代码开发中应该做的事情 使用gzip压缩 不要使用同步函数 不要直接日志 正确的处理异常 环境和部署中要做的事情 NODE_ENV设置了”production” 确保应用能自动重启 以集群的方式运行应用 缓存请求结果 使用负载均衡 使用反向代理 在代码开发中应该做的事情使用gzip压缩Gzip压缩可以很大程度的减小返回响应body的大小，加快web应用的速度 。 在Express应用中使用压缩中间件。如下示例：1234var compression = require('compression')var express = require('express')var app = express()app.use(compression())在高并发的网站生产环境中， 最好的方法是把压缩放在反向代理层面（参考使用反向代理）。 在这种情况下，你不需要使用压缩中间件。如何在Nginx中启用Gzip压缩请参考Nginx文档 Module ngx_http_gzip_module。不要使用同步函数同步函数和方法阻塞一直到他们返回。一个同步函数返回需要几微秒或几毫秒， 在高并发的站点，这些请求会降低应用的性能。需要避免在生产环境中使用。虽然 Node和其它许多模块为它们的功能提交了同步和异步版本，永远在产品中使用异步版本。唯一可以使用的是在初始化应用过程。如果你使用Node.js 4.0 + 或者 io.js 2.1.0+ , 你可以使用–trace-sync-io 命令行标志来输入使用同步API的调用栈告警。 当然，你不想在产品中使用它，当你需要确保你的代码已经准备好了在生产环境中使用。更多信息参考 Node命令行选项文档不要记录直接日志通常， 记录日志有两个原因：调试和记录应用事件。 在开发过程中使用console.log(), console.error()打印日志消息到终端非常常见。 但是这些函数是同步，当目标是一个终端或者文件的时候，因此，这些不太多我刚看在生产环境中使用，除非你输出放到另一个应用中。#### 调试日志如果为了调试记录日志，可以使用一个类似debug的模块来代替console.log()。 这个模块允许你使用DEBUG环境变量来控制哪种类型调试消息发送到console.err(),如果有的话。 为了保证应用完全的异步， 你可能还是需要将console.err()管道到另外一个程序。 但是在那种情况下，你不是真正的在生产环境调试。#### 应用事件日志如果为了记录应用事件（如，流量、API调用）等， 可以使用类似Winston或Bunyan的日志库来代替使用console.log()。 更多关于这两个库对比的信息可以参才StrongLoop的博客Comparing Winston and Bunyan Node.js Logging.正确的处理异常Node应用遇到没有被捕获的异常时将会崩溃。如果没有处理异常和合适的动作将会使用Express应用崩溃或离线 。#### 不要做的事情#### 使用try-catch#### 使用promise## 环境和部署中要做的事情NODE_ENV设置了”production” 确保应用能自动重启 以集群的方式运行应用 缓存请求结果 使用负载均衡 使用反向代理","categories":[{"name":"node.js","slug":"node-js","permalink":"http://www.gistop.com/categories/node-js/"},{"name":"express","slug":"node-js/express","permalink":"http://www.gistop.com/categories/node-js/express/"},{"name":"porformance and reliability","slug":"node-js/express/porformance-and-reliability","permalink":"http://www.gistop.com/categories/node-js/express/porformance-and-reliability/"}],"tags":[{"name":"performance","slug":"performance","permalink":"http://www.gistop.com/tags/performance/"},{"name":"reliability","slug":"reliability","permalink":"http://www.gistop.com/tags/reliability/"}]},{"title":"Express应用生产环境最佳实践： 安全","slug":"node-express-security-best-practice","date":"2018-05-12T06:10:45.000Z","updated":"2018-08-26T06:43:44.970Z","comments":true,"path":"2018/05/12/node-express-security-best-practice/","link":"","permalink":"http://www.gistop.com/2018/05/12/node-express-security-best-practice/","excerpt":"概览术语“production”指软件处于生命周期中应用和服务对于终端用户和消费者可用的阶段。 相反的, 在“development”阶段， 还有编写和测试代码，应用还没有对外部开放。 相对的， 相应的系统环境也称作”production” 和 “development”环境。开发环境和生产环境往往在设置上有很大的差异，需求也有很大的不同。 可能在开发环境中很好的设置，在生产环境中就不可用了。 例如，在开发环境中你需要错误用志用来调试，但在生产环境中这可能是一个安全漏洞。 或许在开发环境中你不需要担心伸缩性部署、可靠性和性能，但在生产环境这有严格的要求。","text":"概览术语“production”指软件处于生命周期中应用和服务对于终端用户和消费者可用的阶段。 相反的, 在“development”阶段， 还有编写和测试代码，应用还没有对外部开放。 相对的， 相应的系统环境也称作”production” 和 “development”环境。开发环境和生产环境往往在设置上有很大的差异，需求也有很大的不同。 可能在开发环境中很好的设置，在生产环境中就不可用了。 例如，在开发环境中你需要错误用志用来调试，但在生产环境中这可能是一个安全漏洞。 或许在开发环境中你不需要担心伸缩性部署、可靠性和性能，但在生产环境这有严格的要求。 在生产环境中安全的最佳实践包括以下方面。 不使用过时的或有安全漏洞的Express版本 使用TSL 使用Helmet 安全的使用cookies 确保依赖资源是安全的 防止其它已知的安全漏洞 更多可以考虑的方面 不使用过时的或有安全漏洞的Express版本 Express 2.x 和 3.x已经不在维护。 这些版本的安全问题将不会解决。 不要再使用这些版本。 如果还没有迁移到 版本 4，请参考 迁移向导。 同时确保你没有使用有安全风险的Express版本， 参考安全更新页面。 如果有， 请更新到稳定版本，最好是最新的稳定版本。 使用TSL如果你的应用需要处理或传输敏感的数据， 使用Transport Layer Security(TLS)来保证数据连接安全。 这项技术在数据从客户端发送到服务器前对数据进行加密，这样可以防止一些常见的（容易）的攻击。 虽然 Ajax和Post请求不是明显示可见， 看起来隐藏在浏览器后面， 但网络传输存在着被抓包和中间层攻击的风险。你可能很熟悉Secure Socket Layer(SSL)加密。TLS是SSL的新一阶段的产品.aspx)。也就是说，如果你已经在使用SSL， 可以考虑升级到TLS。 通常，建议使用Nginx来处理TLS。 在Nginx中配置TLS,请参考 Recommended Server Configurations (Mozilla Wiki)另外，Let’s Encrypt 一个方便的获取免费的TLS证书的工具, 它是由Internet Security Research Group (ISRG)提供的开方的CA工具。使用HelmetHelmet可以通过合适的设置http协议头帮助保护应用远离一些常见的Web安全隐患。Helmet 确切的说就是9个小的设置安全相关的http协议头的中间件函数的集合：- CSP 设置 Content-Security-Policy 头 帮助防止跨站脚本攻击和跨站脚本注入。- HidePoweredBy 移除X-Powered-By 头。- hpkp 添加Public Key Pinning 头，防止通过伪造证书书的man-in-the-middle攻击。- hsts 设置Strict-Transport-Security 头加强（HTTP Over SSL/TLS）到服务器的连接。- ieNoOpen 设置X-Download-Operation for IE8+。- noCache 设置Cache-Control和Pragma头。- noSniff 设置X-Content-Type-Options 以防止浏览器被MIME-Sniffing通过已经定义的content-type。- xssFilter 设置X-XSS-Protection 以在大多数现代浏览器中启用跨站脚本过滤。安装Helmet和其它模块一样：1$ npm install --save helmet然后在代码中使用：123456// ...var helmet = require('helmet')app.use(helmet())// ...### 至少移除 X-Powered-By 头如果你不想使用 Helmet, 至少移除X-Powered-By 头。 攻击者可以使用这个头（通常被默认开启） 来探测Express应用，并执行特定目标的攻击。因此，最好的方法是使用app.disable()方法关闭这个头:1app.disable('x-powered-by')如果你使用Helmet, 它将帮你做这些。安全的使用cookies确保cookies不会停你的用应暴露给其它方，不要使用默认的cookie名称，合理的设置cookie安全选项。主要有两个cookie会话相关的中间件模块。- express-session 替换 Express 3.x内置的express.session中间件。- cookie-session 替换 Express 3.x 内容的express.cookieSession.这两个模块的主要区别是如何保存cookes会话信息。 express-session模块在服务器端存储会话信息， 它仅仅在cookie中保存session ID， 不舍保存会话数据。 默认下， 它使用内存存储， 这不适合在生产环境中使用。 在生产环境中，需要创建一个可伸缩的会话存储，查看[兼容的会话存储]列表(https://github.com/expressjs/session#compatible-session-stores)。相反的， cookie-session 中间件实现了基于cookie的存储： 它将整个会话序列化成cookie， 而不仅仅是会话key。只有在传话数据相当小且很容易具很容易编码成基本数据值的情况下使用。 浏览器支持至少4096字节大小的cookie，确保不会超出这个限制， 每个域名下的cookie大小不要超过4093字节。 另外，需要考虑cookie数据是在客户端可见的， 在考虑安全和隐私的情况下 express-session会是更好的选择。### 不要使用默认的会话cookie名称使用默认的会话cookie名称会使你的应用容易被攻击。 这个问题暴露类似于X-Powered-By的风险： 潜在的攻击者可以使用这个特点有针对的进行攻击。避免这个问题，使用通用的cookie名称; 例如, 使用 express-session 中间件：123456var session = require('express-session')app.set('trust proxy', 1) // trust first proxyapp.use(session(&#123; secret: 's3Cur3', name: 'sessionId'&#125;))### 设置Cookie 安全选项设置以下cookie选项加强安全：- secure - 确认浏览器使用https情况下传输cookie。- httpOnly - 确认cookie只在http(s)中传输，不可以在客户端JavaScript更改， 以防止跨站脚本攻击。- path - 指明cookie的路径， 使用它来对比请求路径。 在路径和域一致的情况下才发送cookie。- expires - 为持久化的cookie设置过期时间。下面是一个使用cookie-session中间件的示例：12345678910111213141516var session = require('cookie-session')var express = require('express')var app = express()var expiryDate = new Date(Date.now() + 60 * 60 * 1000) // 1 hourapp.use(session(&#123; name: 'session', keys: ['key1', 'key2'], cookie: &#123; secure: true, httpOnly: true, domain: 'example.com', path: 'foo/bar', expires: expiryDate &#125;&#125;))确保依赖资源是安全的 使用npm来管理依赖，功能很强大，也很方便。 但是使用这些包也可能带来致命的安全隐患。 应用的安全将和你链接到你应用中的最弱的依赖一样。 使用以下两个工具任一或全部来确保第三方包的安全： nsp 和 Snyk。 nsp 是一个检测Node安全项目隐患数据库来判断应用是否使用了带有已经安全隐患的第三方包。 安装方式如下： 1$ npm i nsp -g 使用以下命令来提交npm-shringkwarp.json/package.json文件到https://nodesecurity.io/验证： 1$ nsp check Snyk 提供了命令行工具，也提供了图形界对比Snyk’s open source vulnerability database检测应用的第三方依赖是否存在安全风险。 安装Cli工具： 12$ npm i -g snyk$ cd your-app 使用命令行检测安全风险 1$ snyk test 使用以下命令行打开一个引导更新和修复安全风险的向导：12$ snyk wizard 防止其它已知的安全漏洞密切关注 Node Security Project 和 Snyk关于Express或你应用使用到的其它模块的建议。 另外，这些数据库也是Node安全方面的优秀的资源和工具。最后， Express应用和其它Web应用一样，面临着各种各样的Web攻击。学习和了解这些Web安全风险，并小心避免它们。更多可以考虑的方面 下面还有一些来自于Node.js Security Checklist更进一点的建议。 参考上述博客获取更详细的信息： 实施速率限制避免对身份验证的暴力攻击。 一个可行的方法是使用StrongLoop API Gateway来增加频率限制策略。或者， 你可以使用express-limiter， 但是这样要求你修改特定的代码。 使用 csurf中间件防止跨站请求伪造攻击。 总是过滤和检测用户输入，防止跨站脚本攻击和命令注入。 使用参数化和预定义表达式（存储过程）来防止SQL注入风险。 使用开源的 sqlmap工具来检测应用中SQL注入风险。 使用nmap 和sslyze工具来检测SSL密码,密钥，以及证书的有效性。 使用safe-regex来确保正则表达式不容易被regular expression denial of service攻击。","categories":[{"name":"node.js","slug":"node-js","permalink":"http://www.gistop.com/categories/node-js/"},{"name":"express","slug":"node-js/express","permalink":"http://www.gistop.com/categories/node-js/express/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://www.gistop.com/tags/node-js/"},{"name":"security","slug":"security","permalink":"http://www.gistop.com/tags/security/"},{"name":"TLS","slug":"TLS","permalink":"http://www.gistop.com/tags/TLS/"}]},{"title":"Express应用的进程管理器","slug":"node-process-manager","date":"2018-05-12T04:18:25.000Z","updated":"2018-08-26T06:43:44.970Z","comments":true,"path":"2018/05/12/node-process-manager/","link":"","permalink":"http://www.gistop.com/2018/05/12/node-process-manager/","excerpt":"当Express应用运行在生产环境时， 使用一个进程管理器来达到以下目标是非常有帮助的： 当应用崩溃时，重启应用 获取应用的运行性能和资源点用情况 动态修改应用设置以改进运用的性能 管理集群 进程管理器类似于应用服务器：是一个方便应用的部署，提供可用性，允许在运行时管理应用的应用容器。","text":"当Express应用运行在生产环境时， 使用一个进程管理器来达到以下目标是非常有帮助的： 当应用崩溃时，重启应用 获取应用的运行性能和资源点用情况 动态修改应用设置以改进运用的性能 管理集群 进程管理器类似于应用服务器：是一个方便应用的部署，提供可用性，允许在运行时管理应用的应用容器。 下面是Express应用和其它node.js应用最流行的进程管理器： Forever PM2 StrongLoop Process Manager SystemD 使用上述4个中的任一个都非常有帮助，其中StrongLoop Process Manager 是其中唯一提供完整的运行时和部署解决方案的。它管理Node.js应用的整个生命周期，为发布成到生产环境前后的每一步在统一的界面中提供工具。 下面是对于这个工具的简短的介绍。查看更多的详细信息， 参阅 http://strong-pm.io/compare/。 Forever Forever 是一个保证指定脚本持续运行的一个简单的命令行工具。Forever的简洁的界面使它成为一个部署运行小Node.js应用和脚本的好的选项。 更多信息，请参考 https://github.com/foreverjs/forever。 安装1$ [sudo] npm install forever -g 基本使用使用forever的启动命令行和脚本路径启动一个脚本：1$ forever start path/to/script.js 这个命令行会使用守护进程模式运行脚本(在后台进程)。 如果要在当前终端运行脚本，可以省略start:1$ forever script.js 更好的做法是使用Forever工具记录日志输出，如下所示在命令行中添加-l, -o, -e选项：1$ forever start -l forever.log -o out.log -e err.log path/to/script.js 查看所有使用Forever启动的脚本：1$ forever list 停止使用Forever启动的脚本可以使用Forever的停止命令行 指定进程的索引（在forever list命令行列表中可以查看）1$ forever stop 1 或者也可以指定脚本的路径：1$ forever stop path/to/script.js 停止所有使用Forever启动的脚本：1$ forever stopall Forever提供了非常多的设置，也提代的可编程的API。 PM2 PM2是一个Node.js应用生产环境的进程管理器，它内置了负载均衡。PM2保持应用一直运行，可以在不停止服务的下重新加载，同时也方便一些通用的系统任务管理。 PM2可以管理应用的日志、监控和集群。 更多信息， 请参考 https://github.com/Unitech/pm2。 安装1$ [sudo] npm install pm2 -g 基本使用使用pm2命令行启动应用时， 必须指定应用的路径。在停止，重启，删除应用时可以只需要指定应用名或者应用的Id。12345678$ pm2 start app.js[PM2] restartProcessId process id 0┌──────────┬────┬──────┬───────┬────────┬─────────┬────────┬─────────────┬──────────┐│ App name │ id │ mode │ pid │ status │ restart │ uptime │ memory │ watching │├──────────┼────┼──────┼───────┼────────┼─────────┼────────┼─────────────┼──────────┤│ my-app │ 0 │ fork │ 64029 │ online │ 1 │ 0s │ 17.816 MB │ disabled │└──────────┴────┴──────┴───────┴────────┴─────────┴────────┴─────────────┴──────────┘ Use the `pm2 show &lt;id|name&gt;` command to get more details about an app. 全用pm2命令行启动应用，应用立即在后台运行。可以使用多种多样的pm2命令行来管理在后台运行的应用。 pm2启动应用行，在pm2的应用列表中注册并得到了一个ID。 你可以使用这些IDs在不同的环境和目录下管理这些应用。 如果有超过一个应用具有相同的name,在同时运行， pm2命令行执行会影响全部具有相同name的应用，因此，建议使用IDs替代name来管理不同的应用。 列出所有正在运行的进程：1$ pm2 list 停止一个应用：1$ pm2 top 0 重启一个应用：1$ pm2 restart 0 显示一个应用的详细信息：1$ pm2 show 0 从pm2注册列表中移除一个应用:1$ pm2 delete 0 StrongLoop Process Manager StrongLoop Process Manage(StrongLoop PM) 是一个Node.js应用生产环境进程管理器。 StrongLoop PM 内置了负载均衡， 监控和多服务器部署，也提提供了一个图形界面的控制台。可以使用StrongLoop PM来完成以下任务： 构建、打包和部署Node.js应用到本地或远程环境 查看CPU性能内存快照以优化性能和发现内存泄漏 保持进程和集群持续运行 查看应用性能矩阵 内置nignx方便的管理多个应用服务器 可以将多个StrongLoop PM 以分布式微服务的方式使用Arc统一管理。 可以使用叫slc的强大的命令行接口来使用StrongLoop PM， 也可以使用一个叫Arc的图形化工具来使用StrongLoop PM. Arc已经开源，StrongLoop提供专业的支持。 更多信息，参考 http://strong-pm.io/ 完整的文档： Operating Node apps (StrongLoop documentation) Using StrongLoop Process Manager 安装1$ [sudo] npm install -g strongloop 基本用法12$ cd my-app$ slc start 查看进程管理器的状态和所有的部署的应用:123456789101112131415$ slc ctlService ID: 1Service Name: my-appEnvironment variables: No environment variables definedInstances: Version Agent version Cluster size 4.1.13 1.5.14 4Processes: ID PID WID Listening Ports Tracking objects? CPU profiling? 1.1.57692 57692 0 1.1.57693 57693 1 0.0.0.0:3001 1.1.57694 57694 2 0.0.0.0:3001 1.1.57695 57695 3 0.0.0.0:3001 1.1.57696 57696 4 0.0.0.0:3001 列出管理的所有的应用(服务):123$ slc ctl lsId Name Scale 1 my-app 1 停止一个应用1$ slc ctl stop my-app 重启一个应用：1$ slc ctl restart my-app 也可以“软重启”, 这样允许正在运行的进程有一个优雅的时间来关闭已经有链接后，再重启应用。1$ slc ctl soft-restart my-app 从管理器中移除一个应用:1$ slc ctl remove my-app SystemD 介绍SystemD是现代Linux版本中默认的进程管理器。基于SystemD运行一个Node.js应用非常简单。下面的内容引自 Ralph Slooten (@axllent)的一篇博客。 创建服务创建文件/etc/systemd/system/express.service:12345678910111213141516171819202122232425[Unit]Description=Express# Set dependencies to other services (optional)#After=mongodb.service[Service]# Run Grunt before starting the server (optional)#ExecStartPre=/usr/bin/grunt# Start the js-file starting the express serverExecStart=/usr/bin/node server.jsWorkingDirectory=/usr/local/expressRestart=alwaysRestartSec=10StandardOutput=syslogStandardError=syslogSyslogIdentifier=Express# Change to a non-root user (optional, but recommended)#User=&lt;alternate user&gt;#Group=&lt;alternate group&gt;# Set environment optionsEnvironment=NODE_ENV=production PORT=8080[Install]WantedBy=multi-user.target 使服务可用1$ systemctl enable exress.service 启动服务1$ systemctl start express.service 查看服务状态1$ systemctl status express.service","categories":[{"name":"node.js","slug":"node-js","permalink":"http://www.gistop.com/categories/node-js/"},{"name":"express","slug":"node-js/express","permalink":"http://www.gistop.com/categories/node-js/express/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://www.gistop.com/tags/node-js/"},{"name":"express","slug":"express","permalink":"http://www.gistop.com/tags/express/"},{"name":"process manager","slug":"process-manager","permalink":"http://www.gistop.com/tags/process-manager/"},{"name":"forever","slug":"forever","permalink":"http://www.gistop.com/tags/forever/"},{"name":"pm2","slug":"pm2","permalink":"http://www.gistop.com/tags/pm2/"},{"name":"StrongLoop Process Manager","slug":"StrongLoop-Process-Manager","permalink":"http://www.gistop.com/tags/StrongLoop-Process-Manager/"},{"name":"SystemD","slug":"SystemD","permalink":"http://www.gistop.com/tags/SystemD/"}]},{"title":"开发Express模版引擎","slug":"node-express-template-engine","date":"2018-05-12T04:00:05.000Z","updated":"2018-08-26T06:43:44.970Z","comments":true,"path":"2018/05/12/node-express-template-engine/","link":"","permalink":"http://www.gistop.com/2018/05/12/node-express-template-engine/","excerpt":"使用app.engine(ext, callback) 方法创建根据模版扩展名自定义的模版引擎。第二个参数 callback回调函数是模版引擎函数，它接收如下参数： 文件路径(filePath) 设置选项(options) 回调函数(callback) 下面的代码是一个实现非常简单可以渲染.ntl文件的模版引擎示例。","text":"使用app.engine(ext, callback) 方法创建根据模版扩展名自定义的模版引擎。第二个参数 callback回调函数是模版引擎函数，它接收如下参数： 文件路径(filePath) 设置选项(options) 回调函数(callback) 下面的代码是一个实现非常简单可以渲染.ntl文件的模版引擎示例。123456789101112var fs = require('fs') // this engine requires the fs moduleapp.engine('ntl', function (filePath, options, callback) &#123; // define the template engine fs.readFile(filePath, function (err, content) &#123; if (err) return callback(err) // this is an extremely simple template engine var rendered = content.toString().replace('#title#', '&lt;title&gt;' + options.title + '&lt;/title&gt;') .replace('#message#', '&lt;h1&gt;' + options.message + '&lt;/h1&gt;') return callback(null, rendered) &#125;)&#125;)app.set('views', './views') // specify the views directoryapp.set('view engine', 'ntl') // register the template engine 这样应用就可以渲染.ntl的文件了。在views目录下创建一个命名为index.ntl的文件。文件内容如下。12#title##message# 然后在应用中添加如下路由。123app.get('/', function (req, res) &#123; res.render('index', &#123; title: 'Hey', message: 'Hello there'&#125;)&#125;) 当你请求主页时，index.ntl 会被渲染成HTML。","categories":[{"name":"node.js","slug":"node-js","permalink":"http://www.gistop.com/categories/node-js/"},{"name":"express","slug":"node-js/express","permalink":"http://www.gistop.com/categories/node-js/express/"}],"tags":[{"name":"express template","slug":"express-template","permalink":"http://www.gistop.com/tags/express-template/"},{"name":"engine","slug":"engine","permalink":"http://www.gistop.com/tags/engine/"}]},{"title":"DOM Event 事件","slug":"web-ui-event","date":"2018-05-08T09:00:18.000Z","updated":"2018-08-26T06:43:44.974Z","comments":true,"path":"2018/05/08/web-ui-event/","link":"","permalink":"http://www.gistop.com/2018/05/08/web-ui-event/","excerpt":"最近一段时间，在面试和被面试过程中都有关于DOM事件的一些交流和沟通，有jQuery对象实例中的事件，也有React组件中的事件，觉得有必要温故一下相关的知识，查看了一些资料，记录下。主要包括以下方面内容。 DOM事件结构 事件类型 自定义事件和事件扩展 几个特殊的事件","text":"最近一段时间，在面试和被面试过程中都有关于DOM事件的一些交流和沟通，有jQuery对象实例中的事件，也有React组件中的事件，觉得有必要温故一下相关的知识，查看了一些资料，记录下。主要包括以下方面内容。 DOM事件结构 事件类型 自定义事件和事件扩展 几个特殊的事件 UI Events设计主要有两个目标。一是， 设计一个事件系统：允许注册事件监听者，通过树型结构订阅事件。二是，为当前浏览器使用的事件系统定义一个通用的子集，用来增加对已存在脚本和内容的交互。 DOM 事件结构事件发布和DOM事件流下面概要的介绍下事件发布机制和事件如何在DOM树中冒泡。应用可以使用dispatchEvent()方法来发布事件对象，事件对象会根据DOM事件流在DOM树中冒泡。下图描述了事件使用DOM事件流在DOM树中冒泡的过程。 事件对象发布到特定的事件目标。在事件可以发布以前，先要确定事件的冒泡路径。冒泡路径是事件对象传递的当前事件目标的有序列表。这个路径依赖DOM树的结构。列表中最后一个元素是事件源，前面的元素是事件源祖先元素，紧挨着事件源的元素是事件源的父元素。一旦冒泡路径确定，事件对象开始传递。 事件过程包括3个阶段： 捕获阶段、目标阶段、冒泡阶段。事件对象完成如下面描述的这些阶段。如果鞭一个阶段不被支持或者冒泡被中止了，这个阶段将被忽略。例如， bubbles 属性被设置成false， 冒泡阶段将被忽略， 或者如果 stopePropagation() 在发布前被调用， 所有的阶段将被忽略。 捕获阶段事件对象从window对象依次通过事件源的祖先元素传播到事件源。 目标阶段事件到达事件对象的事件源。也叫at-target阶段。 如果事件类型中指明了事件不冒泡，事件将在这个阶段结束后停止。 冒泡阶段事件依照逆序在事件源的视先对象中传递，直到window对象结束。 事件类型DOM事件对象模型允许DOM实现多个事件模块。这个模型被设计成允许在未来添加更多的新事件模块。为了交互能力，DOM定义了用户界面事件，包括低级别的依赖设备的事件和DOM改变事件。 UI事件类型load接口: 如果是从用户界面元素产生则是UIEvent，否则是Event同步/异步: 异步冒泡： 否元素类型： Window, Document, Element是否可取消: 否默认行为： 无 当一个实现这个接口的DOM完成资源加载(例如Document)和任何的依赖资源(如图片、样式文件、脚文件等)客户端必须发布这个事件。依赖资源加载失败不会阻止这个事件的触发。 unload接口: 如果是从用户界面元素产生则是UIEvent，否则是Event同步/异步: 同步冒泡： 否元素类型： Window, Document, Element是否可取消: 否默认行为： 无 当一个实现这个接口的DOM从环境中移除时客户端必须发布这个事件。 abort接口: 如果是从用户界面元素产生则是UIEvent，否则是Event同步/异步: 同步冒泡： 否元素类型： Window, Element是否可取消: 否默认行为： 无 当用户取消一个正在加载中的资源加载时，客户端必须发布这个事件。 error接口: 如果是从用户界面元素产生则是UIEvent，否则是Event同步/异步: 异步冒泡： 否元素类型： Window, Element是否可取消: 否默认行为： 无 当一个资源加载失败或资源不能正确使用，或脚本执行出错，以及不正确的XML格式时，客户端必须发布这个事件。 select接口: 如果是从用户界面元素产生则是UIEvent，否则是Event同步/异步: 同步冒泡： 否元素类型： Element是否可取消: 否默认行为： 无 当文本被选中，客户端必须发布这个事件。这个事件在文本已经被选中时发生。 Focus事件接口定义FocusEvent 接口提供了几个特定与Focus事件相关的上下文信息。 .relatedTarget依据事件类型，用来表示第二个与Focus事件相关的事件源 Focus事件顺序用户切换焦点 focusin在第一事件源接收焦点前触发 focus在第一事件源接收焦点后触发 focusout在第一事件源失去焦点前触发 focusin在第二事件源接收焦点前触发 blur在第一事件源失去焦点后触发 focus在第二事件源接收焦点后触发 Focus事件类型blur接口: FocusEvent同步/异步: 同步冒泡： 否元素类型： Window, Element是否可取消: 否默认行为： 无 事件源失去焦点客户端必须发布这个事件。这个事件在文本已经被选中时发生。 focus接口: FocusEvent同步/异步: 同步冒泡： 否元素类型： Window, Element是否可取消: 否默认行为： 无 事件源接收焦点后客户端必须发布这个事件。这个事件在文本已经被选中时发生。 focusin接口: FocusEvent同步/异步: 同步冒泡： 否元素类型： Window, Element是否可取消: 否默认行为： 无 事件源获得焦点前客户端必须发布这个事件。这个事件在文本已经被选中时发生。 focusout接口: FocusEvent同步/异步: 同步冒泡： 否元素类型： Window, Element是否可取消: 否默认行为： 无 事件源将要失去焦点客户端必须发布这个事件。这个事件在文本已经被选中时发生。 鼠标事件（MouseEvent）滚动事件 (WheelEvent)输入事件 (InputEvent)键盘事件 (KeyboardEvent)DOM结构改变事件 (MutationEvent)Mutation事件设计允许获取文档结构变化的通知，也包括属性、文本和名称 的修改。 接口定义1234567891011121314interface MutationEvent : Event &#123; // attrChangeType const unsigned short MODIFICATION = 1; const unsigned short ADDITION = 2; const unsigned short REMOVAL = 3; readonly attribute Node? relatedNode; readonly attribute DOMString prevValue; readonly attribute DOMString newValue; readonly attribute DOMString attrName; readonly attribute unsigned short attrChange; void initMutationEvent();&#125;; MutationEvent事件类型DOMAttrModified接口: MutationEvent同步/异步: 同步冒泡：是元素类型： Element是否可取消: 否默认行为： 无 节点的属性值被修改，或属性被添加、移除客户端必须发布这个事件。 DOMCharacterDataModified接口: MutationEvent同步/异步: 同步冒泡：是元素类型： Text, Comment, ProcessingInstruction是否可取消: 否默认行为： 无 CharactData.data或ProcessingInstruction.data被修改，但节点自身没有被插入或删除时客户端必须发布这个事件。 DOMNodeInserted接口: MutationEvent同步/异步: 同步冒泡：是元素类型：Element, Attr, Text, Comment, DocumentType, ProcessingInstruction是否可取消: 否默认行为： 无 当一个节点或属性作为子节点添加到另外一个节点时客户端必须发布这个事件。 DOMNodeInsertedIntoDocument接口: MutationEvent同步/异步: 同步冒泡：是元素类型：Element, Attr, Text, Comment, DocumentType, ProcessingInstruction是否可取消: 否默认行为： 无 当一个节点或属性作为子节点添加到一个文档时客户端必须发布这个事件。直接或间接加到文档中都会触发，如所在的父节点被添加到文档中。 DOMNodeRemoved接口: MutationEvent同步/异步: 同步冒泡：是元素类型：Element, Attr, Text, Comment, DocumentType, ProcessingInstruction是否可取消: 否默认行为： 无 当一个节点或属性被移除时客户端必须发布这个事件。 DOMNodeRemovedFromDocument接口: MutationEvent同步/异步: 同步冒泡：是元素类型：Element, Attr, Text, Comment, DocumentType, ProcessingInstruction是否可取消: 否默认行为： 无 当一个节点或属性从文档中被移除时客户端必须发布这个事件。直接或间接从文档中移除都会触发这个事件。 DOMSubtreeModified接口: MutationEvent同步/异步: 同步冒泡：是元素类型：Window, Document, DocumentFragment, Element, Attr是否可取消: 否默认行为： 无 这是一个概括的事件对应任何的文档变化，可以用来替代其它的Mutation事件。 几个相关对象介绍MutationObserver构造函数该构造函数用来实例化一个新Mutation观察者对象。123new MutationObserver( function callback); 参数 callback该回调函数会有指定的DOM节点发生变化时被调用，在调用时，观察者对象会传给该函数两个参数， 第一个参数是包含了若干个MutationRecord对象的数组， 第二个参数则是这个观察者对象本身。 实例方法 .observe1void observe(Node target, optional MutationObserverInit options); 给当前观察者对象注册需要观察的目标节点，在目标俺不会空（还可以同时观察其后代节点）发生DOM变化时收到通知。 .disconnect1void disconnect(); 让该观察者对象停止观察指定目标的DOM变化，直到再次调用其observe()方法 .takeRecords1Array takeRecords(); 返回值返回一个包含了MutationRecord的对象数组。 MutationObserverInit是一个用来配置观察者对象行为的对象，具有以下属性： 属性 描述 childList 如果需要观察目标节点的子节点(新增加了某个子节点或者移除了某个子节点), 则设置为true。 attributes 如果需要观察目标节点的改改（新增加或删除了某个属性，以及某个属性值发生了变化）, 则设置为true。 characterData 如果该节点为characterData节点（一种抽象接口， 具体可以为文本节点，注释节点，以及处理指令节点）时，也要观察该节点的文本内容是否发生了变化，则设置为true。 subtree 除了目标点，如果还需要观察目标节点的所有后代节点（观察目标节点所包含的整棵DOM树上的上述三种节点变化），则设置为true。 attributeOldValue 在attributes 属性设置为true的前提下，如果需要将发生变化的属性节点之前的属性值记录下来（记录到下面MutationRecord对象的orderValue属性中），则设置为true。 attributeFilter 一个属性数组(不需要指定命名空间), 只有该数组中包含的属性发生变化时才会被观察到， 其它属性发生变化后会被忽略。 MutationRecord对象会作为第一个参数传递给观察者对象包含的回调函数，该对象具有以下属性 属性 类型 描述 type String 如果是属性发生变化,则返回attributes。 如果是一个CharacterData节点发生变化,则返回characterData,如果是目标节点的某个子节点发生了变化,则返回childList。 target Node 返回此次变化影响到的节点,具体返回那种节点类型是根据type值的不同而不同的. 如果type为attributes,则返回发生变化的属性节点所在的元素节点,如果type值为characterData,则返回发生变化的这个characterData节点.如果type为childList,则返回发生变化的子节点的父节点. addedNodes NodeList 返回被添加的节点,或者为null。 removedNodes NodeList 返回被删除的节点,或者为null previousSibling Node 返回被添加或被删除的节点的前一个兄弟节点,或者为null. nextSibling Node 返回被添加或被删除的节点的后一个兄弟节点,或者为null. attributeName String 返回变更属性的本地名称,或者为null. attributeNamespace String 返回变更属性的命名空间,或者为null. oldValue String 根据type值的不同,返回的值也会不同.如果type为 attributes,则返回该属性变化之前的属性值.如果type为characterData,则返回该节点变化之前的文本数据.如果type为childList,则返回null. 参考 https://www.w3.org/TR/DOM-Level-3-Events/#dom-event-architecture https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver#Instance_methods","categories":[{"name":"web","slug":"web","permalink":"http://www.gistop.com/categories/web/"},{"name":"dom event","slug":"web/dom-event","permalink":"http://www.gistop.com/categories/web/dom-event/"}],"tags":[{"name":"DOM3","slug":"DOM3","permalink":"http://www.gistop.com/tags/DOM3/"},{"name":"DOM Event","slug":"DOM-Event","permalink":"http://www.gistop.com/tags/DOM-Event/"},{"name":"MutationEvent","slug":"MutationEvent","permalink":"http://www.gistop.com/tags/MutationEvent/"},{"name":"MutationObserver","slug":"MutationObserver","permalink":"http://www.gistop.com/tags/MutationObserver/"},{"name":"Bubble","slug":"Bubble","permalink":"http://www.gistop.com/tags/Bubble/"},{"name":"Capture","slug":"Capture","permalink":"http://www.gistop.com/tags/Capture/"},{"name":"Event Phrase","slug":"Event-Phrase","permalink":"http://www.gistop.com/tags/Event-Phrase/"}]},{"title":"Web网站和应用无障碍访问","slug":"web-accessiblity","date":"2018-04-29T07:48:01.000Z","updated":"2018-08-26T06:43:44.973Z","comments":true,"path":"2018/04/29/web-accessiblity/","link":"","permalink":"http://www.gistop.com/2018/04/29/web-accessiblity/","excerpt":"Web网站和应用都充分的考虑了有障碍人士方便的访问和使用,就是无障碍访问。","text":"Web网站和应用都充分的考虑了有障碍人士方便的访问和使用,就是无障碍访问。 Web站点无障碍访问无障碍访问介绍Web网站和应用的强大在于它的普适性。能为被任何一个人访问,不管他有没有残疾,这是必需。– Tim Berners-Lee, W3c董事和World Wide Web的创立者,如是说。 Web设计从根本上考虑适合每一个,包括硬件,软件,语言,地址和能力。当Web达到这个目标时,它可以服务有听觉、视觉、运行和认知能力问题的人。 Web从根本上消除了许多有残疾人在现实世界存在的沟通和交流障碍。 Web无障碍访问意味着,Web站点、工具和技术的设计和实现,满足有残疾的人适用。具体的说,人们可以: 感知,理解,浏览和与Web交互 为Web做贡献 Web无障碍访问消除所有影响访问Web的缺陷, 包括: 听觉 感知 神经 身体残疾 语言 视觉 Web无障碍访问也使没有缺陷的人受益,例如: 使用手机、智能手表、智能电视、和其它小屏幕,有不同输入模式的设备等 老年人因年龄增长而退化的能力 临时有缺陷的人, 如手臂受伤,或者眼镜丢失了 在特定环境下,如在强列的太阳光线下,或者在一个很吵杂的环境 网络慢或者网络宽带费用很贵的情形 使Web可以无障碍访问可以从以下几个方面考虑增进网站都以有缺陷人士的访问。 Web 无障碍访问设计 Web 无障碍内容编写和展示 Web 无障碍开发 无障碍访问设计 使用强对比的前景色和背景色 当文字颜色和背景色没有足够的对比度的情况下有些人不能阅读;而对于有些人亮度太高的文字阅读不了, 他们需要低亮度。 不要单独使用颜色来传达信息 虽然颜色在传递信息中非常有效, 但不要单独使用颜色来传达信息。 当使用颜色来区分不同的元素时, 需要提供额外的不依赖颜色的标识。比如,使用星号和颜色一起来表示必填项。 可交互的元素需要很容易识别 给可交互的元素添加用来区别的样式, 如, 按钮, 超链接, 使它们一眼就能区别出来。 提供清楚的一致的导航设置 在不同的页面之间的跳转,在命名、样式和放置位置需要一致。 提供多于一种的导航方式,比如网站地图或网站搜索。提供定位线索,如面包屑和头部待帮助用户了解他们在站点或页面中的位置。 表单元素需要的明确的关系标签 每一个表单字段需要有一个描述标签。 在从左到右的语言中, 标签通常显示在字段的左侧或上方, 除了复选框和单选按钮通常是在右边。 在标签和字段中不要留太多的空白。 用户交互需要有明确的响应 响应用户的每一个操作, 比如确认提交表单, 当有错误时显示告警,或者通知用户页面有变化。需要有清晰容易识别的说明。需要用户作出操作的重要的响应需要有突出的样式。 使用标题和留白区别关联的内容 使用空白和靠近使用相关的内容更加明显和突出。给分组的标题特别的样式,减少交错, 使用内容更容易扫描和理解。 为不同大小的视窗做不同的设计考虑页面信息在不同大小的视窗中的展现, 例如, 手机,缩小的桌面浏览器。定位和显示主要的元素, 顶部和导航可以改变, 以达到最好的使用空间。确认文字大小和线宽设置满足最大可读性和易读性。 在您的设计中包含图像和媒体替代品 与内容作者和开发都一起为非文本内容提供替代内容。 为自动启动的内容提供控制 为用户提供停止动画和自动播放的声音的控制。这些需要应用到Carousels, 图片轮播, 背景音乐和视频。 无障碍内容编写 提供有信息的,唯一的页面标题 使用标题表达含意和结构 使用有意义的链接文本 使用用有含意的文本作为图片的替代 为多媒体资源创建清单和标题 提代清晰的向导 保持内容清晰和简洁 无障碍开发 为每一个表单元素添加关联标签","categories":[{"name":"Web","slug":"Web","permalink":"http://www.gistop.com/categories/Web/"},{"name":"accessibility","slug":"Web/accessibility","permalink":"http://www.gistop.com/categories/Web/accessibility/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://www.gistop.com/tags/Web/"},{"name":"accessibility","slug":"accessibility","permalink":"http://www.gistop.com/tags/accessibility/"}]},{"title":"优化Web应用性能(三) 渲染过程的性能优化","slug":"web-performance-rendering","date":"2018-04-28T07:20:00.000Z","updated":"2018-08-26T06:43:44.974Z","comments":true,"path":"2018/04/28/web-performance-rendering/","link":"","permalink":"http://www.gistop.com/2018/04/28/web-performance-rendering/","excerpt":"前一篇中主要介绍了在Web资源加载过程一些性能优化的方法, 下面主要介绍渲染过程中可以考虑和采用的一些性能优化方法。","text":"前一篇中主要介绍了在Web资源加载过程一些性能优化的方法, 下面主要介绍渲染过程中可以考虑和采用的一些性能优化方法。 优化渲染过程Web应用性能优化前两篇中介绍了Web性能优化分 优化渲染过程JavaScript 执行优化 对于动画效果的实现，避免使用 setTimeout 或 setInterval，请使用 requestAnimationFrame。 将长时间运行的 JavaScript 从主线程移到 Web Worker。 使用微任务来执行对多个帧的 DOM 更改。 使用 Chrome DevTools 的 Timeline 和 JavaScript 分析器来评估 JavaScript 的影响帧 将操作处理时间优化到10ms以内 使用requestAnimation 来代替setTimeout,setInterval 尽可能在帧开始时招待处理,而不是在帧后段样式计算 样式选择器占用了50%左右的时间 不使用复杂 文档layout flowLayoutRepaint样式嵌套和样式计算复杂度减少重绘区域大小","categories":[{"name":"Web","slug":"Web","permalink":"http://www.gistop.com/categories/Web/"},{"name":"performance","slug":"Web/performance","permalink":"http://www.gistop.com/categories/Web/performance/"}],"tags":[{"name":"Web Performance","slug":"Web-Performance","permalink":"http://www.gistop.com/tags/Web-Performance/"}]},{"title":"优化Web应用性能(二) 加载过程性能优化","slug":"web-performance-loading","date":"2018-04-27T07:19:44.000Z","updated":"2018-08-26T06:43:44.974Z","comments":true,"path":"2018/04/27/web-performance-loading/","link":"","permalink":"http://www.gistop.com/2018/04/27/web-performance-loading/","excerpt":"上一往篇中前到了Web应用性能包括哪些方面,以及怎么来分析和评价应用的性能。 今天主要来说说,Web资源加载过程中可以考虑和采取的一些优化方法。","text":"上一往篇中前到了Web应用性能包括哪些方面,以及怎么来分析和评价应用的性能。 今天主要来说说,Web资源加载过程中可以考虑和采取的一些优化方法。 优化加载过程Minify uglify, encodingCompress binary compress, gzipLazy loading SPA Order loading thoughtfullyPRPL模式Resource PrioritizitionNever load same resource twice 缓存计算 缓存安装 缓存更新Using Webpack optimize web performance","categories":[{"name":"Web","slug":"Web","permalink":"http://www.gistop.com/categories/Web/"},{"name":"performance","slug":"Web/performance","permalink":"http://www.gistop.com/categories/Web/performance/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://www.gistop.com/tags/Web/"},{"name":"Performance","slug":"Performance","permalink":"http://www.gistop.com/tags/Performance/"},{"name":"Loading","slug":"Loading","permalink":"http://www.gistop.com/tags/Loading/"},{"name":"Precache","slug":"Precache","permalink":"http://www.gistop.com/tags/Precache/"},{"name":"Service Worker","slug":"Service-Worker","permalink":"http://www.gistop.com/tags/Service-Worker/"}]},{"title":"优化Web应用性能(一) Web应用性能概述","slug":"optimize-webpage-performance","date":"2018-04-25T03:10:58.000Z","updated":"2018-08-26T06:43:44.970Z","comments":true,"path":"2018/04/25/optimize-webpage-performance/","link":"","permalink":"http://www.gistop.com/2018/04/25/optimize-webpage-performance/","excerpt":"什么是Web应用的性能? Web应用的性能体现在哪些方面? 怎么样来评价一个Web应用性能的好坏? 这几个看起来是个很傻的问题。对的,这几个问题的确很傻,Web应用的性能好差不就是根据用户用起来爽不爽来评价么是的。性能主要是满足用户的需求，让用户满意。 我们在开发的过程中,由于自己对应用业务的熟悉程度和用户不一样,所以,我们自己在使用我们自己的应用时间,体验可能会跟用户的体验不一样。因此,需要一些具体的评价指标和工具来帮助我看在开发的过程中更好的检验我们开发的应用的性能。下面介绍下RAIL模型来评估应用性能。","text":"什么是Web应用的性能? Web应用的性能体现在哪些方面? 怎么样来评价一个Web应用性能的好坏? 这几个看起来是个很傻的问题。对的,这几个问题的确很傻,Web应用的性能好差不就是根据用户用起来爽不爽来评价么是的。性能主要是满足用户的需求，让用户满意。 我们在开发的过程中,由于自己对应用业务的熟悉程度和用户不一样,所以,我们自己在使用我们自己的应用时间,体验可能会跟用户的体验不一样。因此,需要一些具体的评价指标和工具来帮助我看在开发的过程中更好的检验我们开发的应用的性能。下面介绍下RAIL模型来评估应用性能。 Web应用性能概述RAIL是一种以用户为中心的性能模型。 每个网络应用均具有与其生命周期有关的四个不同方面，且这些方面以不同的方式影响着性能： 以用户为中心；最终目标不是让您的应用在任何特定设备上都能运行很快， 而是使用用户满意。 立即响应用户； 在100毫秒以内确认用户输入。 设置动画或滚动时， 在10毫秒以内生成帧。 最大程度增加主线程的空闲时间。 持续吸引用户，在1000毫秒以内程现内容。 使用RAIL模型评估应用性能关注用户感知，把用户体验当作为你努力的焦点。下表描述了用户感变化与性能延时的关系：用户对性能的感知 时间 用户感知 0 - 16ms 用户特别擅长跟踪动作，他们不喜欢不流畅的动画。用户感知到动画，因为每秒都有60个新帧渲染出来。 也就是每16ms秒1帧，包生成帧和浏览器把帧渲染到屏幕的时间，也就是说，应用可以有大约10毫秒的时间来生成一帧。 0 - 100ms 当咋就用户操作在100ms以内时， 用户感知是立即响应。 如果超出了这个范围，用户就感觉到操作和响应不是连续的。 100 - 100ms 用户会感觉到轻微的延时。 300 - 1000ms 在这个窗口中，事物感觉是任务的自然和持续进展的一部分。 对于网络上的大多数用户来说，加载页面或更改视图代表了一项任务。 1000ms 以上 超过1秒， 用户关注的焦点会从他们正在执行的活动中转移。 10000ms 以上 超过10秒， 用户会感到扫兴，或许会终止他们正当前的活动，也许再也不回来了。 要根据 RAIL 指标评估您的网站，请使用 Chrome DevTools Timeline 工具记录用户操作。然后根据这些关键RAIL指标检查Timeline中的记录时间。 Response在100ms以内完成响应用户操作的过渡动画。 用户花\b费的时间大部分应该\b待应用响应他们的\b输入，而不是\b\b等待网站加载。 在50ms以内响应用户操作 虽然， 看起来有点不合常理，并不在所有情况的可以立即响应用户输入。有的时候可以在100ms以来执行其它比较耗时的操作。但是需要注意的不要中断用\b户操作，在后台执行异步操作。 大于50ms的操作，\b需要提供提示。Animation需要在10ms以内生成帧。技术角度上，每帧最大限度上允许有16ms,但是\b浏览器需要大约6ms的时间来\b渲染一帧，因此，建议10ms每帧。保证视觉上流畅， 用户能察觉到帧率的变化 。 在\b如动画等压力大的情况下，尽可能少的执行计算和操作。在允许的情况下，预先计算和缓存花费时间的工作，以保证有机会达到60fps。 在不同\b场景下优化动画。 意识到所有的动画类别。 动画不仅是花俏的用户界面效果。以下每一种交互都\b被当\b作动画。 视觉上的动画。例如出现，消失，\b过渡，和加载提示。 滚动。 拖动。Idle最大化主线程空闲时间，提高页面在50ms内响应用户输入的可能性。 使用空闲时间执行延迟任务。例如， 在页面初始化的\b时候，尽可能减少加载的数据，然后在空闲的时间去加载剩余的。 在空闲时间执行任务在50ms以内，否则，有可以会引起应用响应用户输入超出50ms的风险。 在空闲时间执行任务时，如果有用户交互操作，用户交互应用有更高的优先级，并且中断当前空闲执行任务。 Load当页面加载慢时，用户的注意力会转移，用户会感觉到操作被中断。加载快的网站，会有更长的会话，更低的跳失率，以及更高的广告可见性。 根据用户使用的设备和网络情况优化加载性能。 渐进性的加载，尽可能在2s内完成页面加载。","categories":[{"name":"web","slug":"web","permalink":"http://www.gistop.com/categories/web/"},{"name":"performance","slug":"web/performance","permalink":"http://www.gistop.com/categories/web/performance/"}],"tags":[{"name":"web performance","slug":"web-performance","permalink":"http://www.gistop.com/tags/web-performance/"},{"name":"rail","slug":"rail","permalink":"http://www.gistop.com/tags/rail/"}]},{"title":"使用VSCode 本地及远程调试Node.js应用","slug":"vscode-debug-node-remote-and-local","date":"2018-02-22T07:45:08.000Z","updated":"2018-08-26T06:43:44.973Z","comments":true,"path":"2018/02/22/vscode-debug-node-remote-and-local/","link":"","permalink":"http://www.gistop.com/2018/02/22/vscode-debug-node-remote-and-local/","excerpt":"记录下使用VSCode 调试Node.js应用相关的内容, 包括Node debugger相关的Source maps, remote debug等。","text":"记录下使用VSCode 调试Node.js应用相关的内容, 包括Node debugger相关的Source maps, remote debug等。 VSCode 的Debugging介绍VSCode 的主要特征之一就是其强大的调试支持功能。 Node.js Inspect 介绍有许多的工具和类库可以用来帮助调试Node.js应用。下面列出了一些。如果不使用工具可以在命令行中添加–inspect标识,然后通过输入的URL连接调试。对于没有使用–inspect启动的Node.js应用,可以传递SIGUSR1信令来激活调试,和打印出连接URL。 Inspect Tools &amp; Clientshttps://nodejs.org/en/docs/inspector/ node-inspect使用VSCode 调试Node.js 应用https://code.visualstudio.com/docs/nodejs/nodejs-debugging VSCode 编辑器内置支持Node.js运行时调试支持,可以调试JavaScript、TypeScript和很多其它可以编译成JavaScript的编程语言。使用VS Code 提供的默认配置和代码片段可以非常简单的设置好Node.js的调试工程。Node.js调试文档提供了更多的关于node.js调试场景的介绍。 你可以找到Source Map, Stepping over external code, 和远程调试等更多调试相关的内容。 由于VSCode Node.js调试器与Node.js运行时通过wire protocol通信,支持的运行时集合由所有支持wire protocol的运行时确定。 当前存在两种wire protocol. legacy: 原生的V8 Debugger Protocol inspector: 新的V8 Inspector Protocol 可以使用–inspect开启. 解决原生V8 debugger protocol 大多数的限制和可扩展性问题。 当前运行时对协议的支持情况如下。 Runtime ‘Legacy’ Protocol ‘Inspector’ Protocol io.js all no node.js &lt; 8.x &gt;= 6.3(windows: &gt;=6.9 Electron &lt; 7.4 &gt;= 7.4 Chakra all not yet 虽然,看起来VS Code Node.js 调试器可以自动选择最合适的协议, 我们还是提供了一个指定特定协议的启动配置属性。 auto: 尝试自动检测运行时使用的协议。 当版本为8.0或者更新时,使用’inspector’ 协议。 当配置中request 类型为‘attach’时, 尝试使用’inspector’协议,如果可用,则使用。由于更早的版本存在几个问题,仅仅当版本&gt;= 6.9时,才使用’inspector’协议。 legacy: 强制node 调试器使用 ‘legacy’协议。 当node 版本 &lt; v8.0 和Electron 版本&lt; 7.4的时候支持。 legacy: 强制node 调试器使用 ‘inspector’协议。 当node 版本 &gt;= 6.3时支持。 目前 Electron 不支持。 在左侧导航Tab选择调试,打开调试面板 在调试Toolbar中点击设置, 打开launch.json使其处于编辑状态 根据工程目录配置 使用VSCode 远程调试Node.js 应用Kill Scripts Signal events 在已经运行的Node应用进程中开启调试 查找pid 1ps | grep node 发送信号 启用调试 1kill -s SIGUSR1 nodepid SIGUSR1 参考https://nodejs.org/api/process.html#process_signal_events 在VSCode调试 打开调试面板 新增调试配置1234567891011121314151617181920212223&#123; // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 \"version\": \"0.2.0\", \"configurations\": [ &#123; \"type\": \"node\", \"request\": \"launch\", \"name\": \"Launch Program\", \"program\": \"$&#123;file&#125;\" &#125;, // 新增加远程调试节点 &#123; \"type\": \"node\", \"request\": \"launch\", \"name\": \"Remote\", \"protocol\": \"auto\", \"address\": \"localhost\", // 修改成对应的远程服务器地址 \"port\": 9229 &#125; ]&#125; 启动调试 在调试toolbar中选择Remote启动方式 点击启动 Command Line Options下表列出了在调时不同标识的作用。 标识 作用 –inspect 启用Inspector 客户端 监听默认的地址和端口（127.0.0.1:9229） –inspect=[host:port] 启用Inspector 客户端绑定指定的地址（127.0.0.1）监听指定端口（9229） –inspect-brk 启用Inspector 客户端监听默认的地址和端口（127.0.0.1:9229）在代码开始执行处进入断点 –inspect-brk=[host:port] 启用Inspector 客户端绑定指定的地址（127.0.0.1）监听指定端口（9229）在代码开始执行处进入断点 node inspect script.js 使用–inspect标识在子进程执行用户代码;在主进程中运行CLI调试 其它使用NIM(Node.js 调试管理工具) 可以自动监听本地的9229端口并自动启动Node.js调试窗口 参考https://chrome.google.com/webstore/detail/nodejs-v8-inspector-manag/gnhhdgbaldcilmgcpfddgdbkhjohddkj 关闭远程调试的inspect","categories":[{"name":"web","slug":"web","permalink":"http://www.gistop.com/categories/web/"},{"name":"node.js","slug":"web/node-js","permalink":"http://www.gistop.com/categories/web/node-js/"},{"name":"IDE","slug":"web/node-js/IDE","permalink":"http://www.gistop.com/categories/web/node-js/IDE/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"http://www.gistop.com/tags/vscode/"},{"name":"debug","slug":"debug","permalink":"http://www.gistop.com/tags/debug/"},{"name":"node","slug":"node","permalink":"http://www.gistop.com/tags/node/"},{"name":"remote debug","slug":"remote-debug","permalink":"http://www.gistop.com/tags/remote-debug/"}]},{"title":"使用正则表达式实现Number.toLocaleString","slug":"regexpression-number-toLocaleString","date":"2017-11-06T08:46:00.000Z","updated":"2018-08-26T06:43:44.972Z","comments":true,"path":"2017/11/06/regexpression-number-toLocaleString/","link":"","permalink":"http://www.gistop.com/2017/11/06/regexpression-number-toLocaleString/","excerpt":"今天做后台项目需要将数据格式化实现,具体需求就是类似将 12345678 转化成12,345,678显示。 虽然, Number.prototype.toLocaleString方法可以方便的实现此功能。但由于toLocaleString 方法的兼容性问题,还需要实现个Polyfill以兼容低版本浏览器。","text":"今天做后台项目需要将数据格式化实现,具体需求就是类似将 12345678 转化成12,345,678显示。 虽然, Number.prototype.toLocaleString方法可以方便的实现此功能。但由于toLocaleString 方法的兼容性问题,还需要实现个Polyfill以兼容低版本浏览器。 Number.prototype.toLocale 功能介绍toLocaleString() 方法返回这个数字在特定语言环境下的表示字符串。 新的 locales 和 options 参数让应用程序可以指定要进行格式转换的语言，并且定制函数的行为。在旧的实现中，会忽略 locales 和 options 参数，使用的语言环境和返回的字符串的形式完全取决于实现方式。 Number.prototype.toLocaleString 兼容性 桌面浏览器兼容性 移动端浏览器兼容器 使用正则表达式正向预查实现简单的Polyfill12345678if (!Number.prototype.toLocaleString) &#123; Number.prototype.toLocaleString = function () &#123; let v = this.toString(); let reg = /\\d&#123;1,3&#125;(?=((\\d&#123;3&#125;)+(\\.\\d+)?)$)/g; v = v.replace(reg, '$&amp;,'); return v; &#125;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://www.gistop.com/categories/前端/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"http://www.gistop.com/categories/前端/JavaScript/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://www.gistop.com/tags/正则表达式/"},{"name":"正向预查","slug":"正向预查","permalink":"http://www.gistop.com/tags/正向预查/"},{"name":"Number","slug":"Number","permalink":"http://www.gistop.com/tags/Number/"},{"name":"toLocaleString","slug":"toLocaleString","permalink":"http://www.gistop.com/tags/toLocaleString/"},{"name":"Polyfill","slug":"Polyfill","permalink":"http://www.gistop.com/tags/Polyfill/"}]},{"title":"2017-01-12 WeexConf","slug":"2017-01-12-weexconf","date":"2017-01-12T11:38:02.000Z","updated":"2018-08-26T06:43:44.966Z","comments":true,"path":"2017/01/12/2017-01-12-weexconf/","link":"","permalink":"http://www.gistop.com/2017/01/12/2017-01-12-weexconf/","excerpt":"很高兴能机有会来weexConf听大牛门的分享,了解weex相关的动态和应用。","text":"很高兴能机有会来weexConf听大牛门的分享,了解weex相关的动态和应用。 分享两张会场的照片。 主持勾股 参会的同学 最期待还是weex market 能够早日上线。 很好兴看到了新版的weex官网和logo. 官网地址: https://weex-project.io/ 文档: https://weex-project.io/references/","categories":[{"name":"web","slug":"web","permalink":"http://www.gistop.com/categories/web/"},{"name":"weex","slug":"web/weex","permalink":"http://www.gistop.com/categories/web/weex/"}],"tags":[{"name":"weex weexConf","slug":"weex-weexConf","permalink":"http://www.gistop.com/tags/weex-weexConf/"}]},{"title":"终极shell, 使用zsh代替bash","slug":"oh-my-zsh","date":"2017-01-08T18:46:00.000Z","updated":"2018-08-26T06:43:44.970Z","comments":true,"path":"2017/01/09/oh-my-zsh/","link":"","permalink":"http://www.gistop.com/2017/01/09/oh-my-zsh/","excerpt":"换到Mac下编码刚好快一年了,感受最大的就是开发效率的提升,使用越来越顺手了,不像最初的一两个星期, 没有了Windows的开妈菜单,总觉得不方便,痛苦一两周过去后,就不想再换到windows下编码了,虽然有时候为了测试万恶的IE浏览器,还有在电脑上安装几个版本的windows的虚拟机。今天要说一下是用起来感觉最爽的神器zsh和oh-my-zsh。那什么是zsh呢?","text":"换到Mac下编码刚好快一年了,感受最大的就是开发效率的提升,使用越来越顺手了,不像最初的一两个星期, 没有了Windows的开妈菜单,总觉得不方便,痛苦一两周过去后,就不想再换到windows下编码了,虽然有时候为了测试万恶的IE浏览器,还有在电脑上安装几个版本的windows的虚拟机。今天要说一下是用起来感觉最爽的神器zsh和oh-my-zsh。那什么是zsh呢? zshZsh 和bash一样,是一种shell。在计算机科学中，Shell俗称壳（用来区别于核），是指“提供使用者使用界面”的软件（命令解析器）。它类似于DOS下的command和后来的cmd.exe。它接收用户命令，然后调用相应的应用程序。Shell 一般分为两大类。一：图形界面shell（Graphical User Interface shell 即 GUI shell）例如：应用最为广泛的 Windows Explorer （微软的windows系列操作系统），还有也包括广为人知的 Linux shell，其中linux shell 包括 X window manager (BlackBox和FluxBox），以及功能更强大的CDE、GNOME、KDE、 XFCE。二：命令行式shell（Command Line Interface shell ，即CLI shell）例如：bash / sh / ksh / csh（Unix/linux 系统）（MS-DOS系统）cmd.exe/ 命令提示字符（Windows NT 系统）Windows PowerShell（支援 .NET Framework 技术的 Windows NT 系统）传统意义上的shell指的是命令行式的shell，以后如果不特别注明，shell是指命令行式的shell。目前常用的 Linux 系统和 OS X 系统的默认 Shell 都是 bash，但是真正强大的 Shell 是深藏不露的 zsh， 这货绝对是马车中的跑车，跑车中的飞行车，史称『终极 Shell』，但是由于配置过于复杂，所以初期无人问津，很多人跑过来看看 zsh 的配置指南，什么都不说转身就走了。直到有一天，国外有个穷极无聊的程序员开发出了一个能够让你快速上手的zsh项目，叫做「oh my zsh」，Github 网址是：https://github.com/robbyrussell/oh-my-zsh。这玩意就像「X天叫你学会 C++」系列，可以让你神功速成，而且是真的。 常用Shell命令 cat 文件名 输出文件内容到基本输出（屏幕 or 加&gt;fileName 到另一个文件） cb 格式化源代码 chmod //change mode，改变文件的权限 cp copy date 当前的时间和日期 echo $abc 在变量赋值之后，只需在变量前面加一个$去引用. lint 语法检查程序 ls dir man help more type du 查看磁盘空间状况 ps 查看当前进程状况 who 你的用户名和终端类型 定义变量 name=abc? (bash/pdksh) || set name = abc (tcsh) mkdir 创建目录 rmdir 删除目录 cd 进入目录 rm 删除文件 more 显示文件 echo 显示指定文本 mv 改文件名 /移动文件 pwd 显示目录路径命令 安装zsh Mac: Mac OS X 中默认安装了zsh。 Ubuntu：sudo apt-get install zsh oh-my-zshOh-my-zsh 是一个开源的,由社区维护的配置zsh的框架。 它提供了非常非常多的有用的功能,插件,主题,还有一些让你兴奋的叫起来的东西… 上面这段话是Oh-my-zsh上抄过来的。原文是英文,由于本人英文差,翻过来很别扭,大家凑合着看。不过,它说明了oh-my-zsh是个什么东西。 安装oh-my-zsh安装非常简单,常用的方式有两种 curl安装 1$ sh -c \"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\" wget安装 1$ sh -c \"$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)\" 自定义设置oh-my-zsh安装完了默认就可以使用了, 不信可以打开你喜欢的terminal.app试试,看下,风格是不是变化了,当然，最主要的不是这个,主要的是各种智能化的提示和目录进入的方式,再不不停的输入cd …了。当然,为了满足你可能有的种种变态的需求,oh-my-zsh也提供了非常的个性化的插件和主题,这些都在~/.oh-my-zsh目录中。如下图除了主题和插件外还有很多其它个性化设置, 具体参见:https://github.com/robbyrussell/oh-my-zsh/wiki/Customization oh-my-zsh插件具体参见:https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins oh-my-zsh主题具体参见https://github.com/robbyrussell/oh-my-zsh/wiki/Themes","categories":[{"name":"Mac","slug":"Mac","permalink":"http://www.gistop.com/categories/Mac/"},{"name":"Tools","slug":"Mac/Tools","permalink":"http://www.gistop.com/categories/Mac/Tools/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"http://www.gistop.com/tags/Shell/"},{"name":"zsh","slug":"zsh","permalink":"http://www.gistop.com/tags/zsh/"},{"name":"oh-my-zsh","slug":"oh-my-zsh","permalink":"http://www.gistop.com/tags/oh-my-zsh/"}]},{"title":"2016年年终总结","slug":"summary-2016","date":"2016-12-31T06:30:00.000Z","updated":"2018-08-26T06:43:44.973Z","comments":true,"path":"2016/12/31/summary-2016/","link":"","permalink":"http://www.gistop.com/2016/12/31/summary-2016/","excerpt":"看着朋友圈,博客,微博到处是朋友们的晒着2016年的成果,2016年的收获,2016年的幸福和2016年的美好回忆。我也忍不住想想自己在这即将过去的2016年里经历了哪些,收获了什么,可想来想去,也没发现自己2016有什么精彩的回忆,或者可以写到年终总结的收获,但不管怎么说也得罗列个几点。 腰围粗了一圈 额头的皱纹深了许多 今年一年换了几次工作, 几乎与前面工作七八年换的次数一样多, 具体是换了三家公司, 换了四个团队,认识了很多牛人,新认识了不少朋友,也增长了不少见识。","text":"看着朋友圈,博客,微博到处是朋友们的晒着2016年的成果,2016年的收获,2016年的幸福和2016年的美好回忆。我也忍不住想想自己在这即将过去的2016年里经历了哪些,收获了什么,可想来想去,也没发现自己2016有什么精彩的回忆,或者可以写到年终总结的收获,但不管怎么说也得罗列个几点。 腰围粗了一圈 额头的皱纹深了许多 今年一年换了几次工作, 几乎与前面工作七八年换的次数一样多, 具体是换了三家公司, 换了四个团队,认识了很多牛人,新认识了不少朋友,也增长了不少见识。 2016年的生活同往年一样,生活很简单,工作日两点一线,周末偶偶也加班,剩下一点时间要么是周末睡个懒觉,约几个朋友打打球锻炼下,原本想着2016至少出去旅行一两次。唉,计划总是很美好,可生活总是有距离。这一年,不少的朋友,结婚,生子,幸福甜蜜,自己依旧单身汪一只,羡慕祝福朋友的同时,也祈祷老天能够眷顾下自己。又到年底了真不知道怎么向爸妈交代,虽然他们现在不会说,也不会问了… 2016年的工作与生活的单调乏味不同,2016年的工作变化挺大的,经历了好几个团队,换了好几家公司。工作上,我应该是挺幸运的,工作过的公司都是非常不错的,一起共事的团队同事也都非常得优秀。年初和现在工作的公司也都是行业中的老大,这在我以前想都不敢想象的。中间的两家公司也都是不差钱,且非常有前景的公司。公司也给了自己认可和非常不错的发展空间。但是还是由于自己的不安分和自己经历,选择一年换了三次工作的尴尬境地。庆幸的是,能来到公司,能加入现在的团队,有着一个经验丰富,又有激情进取的Leader, 有一群年轻有冲劲的小伙伴。废话了好多,简单回顾一下2016在不同团队做的事情。在最初的团队,从2015年底开始,引入前端开发的工程化,引入gulp、webpack等工具,开始要求代码的静态检测、单元测试,进行Code Review,要求团队成员在团队内进行技术分享。Web端实现UI界面供桌面客户端和移动客户端使用。换到第二家公司后,迅速用AngularJs 1.5 搭建了一个IPC配置管理的前端应用。提议IPC服务器端实现与前端通过WebSocket或WebRTC协议传输音视频码流,在Web前端使用JS进行解码,实现Web配置的去控件化。无奈由于在团队呆的时间关系只实现了与第三方设备的Demo,由于公司使用的编码不是标准的MP4编码,通过WebSock传到前端后,无法解码出视频图像。留了一个很大的坑,就换工作了。换到第三家公司后,由于整个公司团队都是一个全新的团队,前端团队的成员原来也都不同的公司,加上公司的业务由很多原来都是由外包团队的实现,在编码风格、代码质量,可扩展可维护性上都有很大的限制。加入团队后,我开始也觉得有些不适应,觉得入手比较慢,在团队内推荐使用统一的技术栈,优化或者替换原来的开发、调试构建工具,实现彻底的前后端独立开发和调试,公司技术老大和协作的后端团队及运维也都支持,在保证业务的提前下,平滑过渡。我选择了在一个新的项目中使用自己按照原有的前端项目工程目录结构和文件组织实现的一个开发、调试构建工具。并在其它项目中要求进行性能上的优化: js bundle包大小,分块,缓存设置,css样式使用post css相关的工具优化, SCSS代码编写上结构优化,上线公共的静态资源服务器,与UED团队沟通好协作流程等。在我和兄弟们热火朝天准备大干一场的时候, 听到了公司技术老大,也就是我的直接Leader要离职创业,公司团队内,也有不少的私下谈论。而又正巧,我收到现在团队的面试电话, 电话中与我现在的Leader沟通也很愉快。而且现在Leader对待技术与分享的观点与我很一致, 我也觉得现在的工作有挑战性,也很的前景和机会,团队面试同学也愿意给我机会。因此,我跟原公司的HR Leader和 公司领导沟通了我的想法,说明了我对到现在工作的大厂工作的向往,虽然,原公司给的机会也很不错,公司BOSS甚至还允诺职级晋升一级,但我真非常向往到大厂工作,也不愿意错过了这次机会,努力的跟BOSS还有HR Leader说明了的诉求,最后终于得到了他们的同意,虽然,后面工作的十多天里BOSS也还问了我几次,想法有没有改变。终于,在12月8号这个吉利的日子里,在年尾的时间,我到我厂办理了入职,加入了现在这个团队。这里的工作节奏也是相当紧凑的,原本我预想入职后,应该会有一两个月相对安逸的时间给自己适应。哪想到,在上午简短的入职培训后,下午领了电脑,开通好想着的帐好权限,设置好邮箱,阿里郞,钉钉,等必备的软件后。就自助到团队所在的办公区域开始准备工作,原本leader 还说会到电梯口接下我,等我培训完准备到8号楼办公区域的时候,由于团队正好在进行一个weex相关的技术分享,由此让我直接到那个分享的会议室了。Oh，my god。 等我到分享的会议室时,分享已经进行Q&amp;A环节了,很遗憾的错过了,全锋同学精彩的分享。这还没完,从分享会议室走出后,Leader跟我说有个中台项目的视觉设计评审,这个需求后面可能会由我负责,让我去参加一下,看时间,那个时候已经快5点了…就这样,开始了我在我厂工作的第一天工作。在接下来工作的日子里,我发现我厂内各种技术资源非常丰富,好的轮子、车子太多了,ATATECT上也有非常多的分享与总结,各式各样的平台也非常的多,不同团队也非常乐意贡献自己造的轮子,这也是我非常期待加入我厂的原因之一。我想自己若能够快速的选择几个,熟悉使用,应该可以让自己的工作更加得心应手些。当然,我也希望自己不仅仅是拿来主义者,也希望可以贡献自己的光和热,哪怕自己造不了车子轮子,只是给现有的轮子添加些润滑济。 展望自己原来是一个GIS工程师,各种机缘巧合下,如今成为了一个专业的前端工程师,像今年D2前端技术论坛的主题一样“初心”。回想自己孩提时,大学刚毕业时的梦想,…。一年又过去了,感慨良多,借用D2论坛的一句话,来结束这个小总结: 回望“初心”, 不惧未来。","categories":[{"name":"生活","slug":"生活","permalink":"http://www.gistop.com/categories/生活/"},{"name":"记录","slug":"生活/记录","permalink":"http://www.gistop.com/categories/生活/记录/"}],"tags":[{"name":"年终总结","slug":"年终总结","permalink":"http://www.gistop.com/tags/年终总结/"},{"name":"2016","slug":"2016","permalink":"http://www.gistop.com/tags/2016/"}]},{"title":"如何过一种清贫而精致的生活","slug":"life-style","date":"2016-12-24T16:00:00.000Z","updated":"2018-08-26T06:43:44.969Z","comments":true,"path":"2016/12/25/life-style/","link":"","permalink":"http://www.gistop.com/2016/12/25/life-style/","excerpt":"穿着John Lewis连锁店的牛仔裤（118英镑／条），开着福特或者丰田自驾旅行，沿途在Waitrose吃午餐，间或欣赏高速公路上的风景；落住乔治王朝时代新古典主义风格的城堡酒店（200英镑／晚），小栖片刻，再漫步到维多利亚时代巴洛克风格的餐厅里吃海鲜大餐（80英镑／人）……这种如牛奶广告里为奶牛搭建的草原生活，固然潇洒惬意，却不是每个人都能消费得起的。好比“金钱买不到快乐，不过假如能让我背对着自己的海景豪宅，在沙滩上喝上一口玛格丽塔，显然更容易让我快乐起来”——这句资本主义国家的流行谚语所定义的“快乐”，也许是真的，却并不一定适用于所有的人。 在英国，且不说海景豪宅，就是拥有一套用来度假的小别墅，年收入至少也要超过6万英镑，95%的人对此望尘莫及。年收入超过3万英镑的中产阶级也只占10%。年收入达不到18600英镑的低收入人群，占47%，有三分之一的人口生活在年收入1万英镑以下。 “清贫”不是一种选择，但是“精致”却可以成为一种选择。如果你不幸被制造成那并不富裕的90%，至少可以通过改变生活方式，为自己的人生带来90%的快乐。以下是我在过了很多年的清贫生活之后，逐渐领悟出来的心得。","text":"穿着John Lewis连锁店的牛仔裤（118英镑／条），开着福特或者丰田自驾旅行，沿途在Waitrose吃午餐，间或欣赏高速公路上的风景；落住乔治王朝时代新古典主义风格的城堡酒店（200英镑／晚），小栖片刻，再漫步到维多利亚时代巴洛克风格的餐厅里吃海鲜大餐（80英镑／人）……这种如牛奶广告里为奶牛搭建的草原生活，固然潇洒惬意，却不是每个人都能消费得起的。好比“金钱买不到快乐，不过假如能让我背对着自己的海景豪宅，在沙滩上喝上一口玛格丽塔，显然更容易让我快乐起来”——这句资本主义国家的流行谚语所定义的“快乐”，也许是真的，却并不一定适用于所有的人。 在英国，且不说海景豪宅，就是拥有一套用来度假的小别墅，年收入至少也要超过6万英镑，95%的人对此望尘莫及。年收入超过3万英镑的中产阶级也只占10%。年收入达不到18600英镑的低收入人群，占47%，有三分之一的人口生活在年收入1万英镑以下。 “清贫”不是一种选择，但是“精致”却可以成为一种选择。如果你不幸被制造成那并不富裕的90%，至少可以通过改变生活方式，为自己的人生带来90%的快乐。以下是我在过了很多年的清贫生活之后，逐渐领悟出来的心得。 第一：尽量让房间“家徒四壁”买不起大房子和昂贵的家具？那么不防学习日本禅室的极简风格，给自己创造一个“家徒四壁”的环境。“物品简化”是一门高度取舍的艺术。音乐和视频不占空间，所以它们可以保留下来；如果能在图书馆里借到书，就尽量借，这也是让图书馆这种珍稀动物能活下去的唯一方法；至于廉价拙劣的家具，大减价扫货回来却永远只穿过一次的衣服鞋子，恶俗的旅游纪念品等等，都可以扔掉。当东西扔得差不多的时候，一种叫做“空”的境界，就会悄然无声地进入到你的内心里。英国佛教大师Ajahn Brahm曾说：“只有空灵，才能安静。”西方的设计师在这种观念的基础上发展了一种叫“Lego”的家居风格，即把琐碎之物尽可能地收纳到壁橱之内，只留下一两件精美而实用的物品。当你在不断舍弃的过程中，终于摆脱了恋物症的纠缠，你就不会整天为买不起这个和那个愁眉苦脸了。 第二：拒绝速食食品在英国，所有人都知道M&amp;S超市的食品质量好，据说牛肉和羊肉都来自没有注射过荷尔蒙的小牛犊和小羊羔，所以价格当然不菲，1.8英镑只能买到100g牛肉，1.85英镑也只能买到100g苏格兰三文鱼等等。然而买不起绿色食品，并不是吃速食食品的理由。 为了让穷人离不开速食食品，生产商用香精添加剂，过量的盐分和糖分，再加上低价等促成各种上瘾因素，让很多穷人欲罢不能，越吃越胖，越胖就越缺乏精力和体力，最后逐渐对自己的存在失去信心。 戒掉速食食品的唯一方法就是亲自动手，自己下厨。我的好朋友Katie，收入不高，却是朋友圈公认的美食家，她和英国作家Jack Monroe是朋友，Jack曾靠《1英镑过一天：低价美食烹调法》一书而名声大噪并上了《时代周刊》，随后成为英国穷人的代言人，英国绿党的中坚力量。她们都是那种可以把茄子做成鱼翅，把月亮做成芝士的女人。Katie把大量的时间花在种菜，做菜，酿酒，自制面包蛋糕和各种果酱上。在M&amp;S，1.44英镑只能买到100g的巧克力橙子蛋糕，而她自己做的大蛋糕，每只预算都不会超过3英镑。 第三：坚持锻炼身体锻炼身体，就像自己动手做菜一样，都是不需要大量的思考，验证，推理和计算，就可以实现的事情。想过精致生活，必须得有一副健康的身体。每天坚持慢跑一到半小时，或者做一个小时瑜伽，尽量骑自行车出行，能游泳的地方就不要坐船（重兵把手的英吉利海峡除外）……日积月累，总有一天你会脱离这副悲苦，肥胖，酸痛满满的皮囊，变成自己想要的样子。 第四：让自己爱上艺术在英国，插花课和制陶课每节要50英镑，比30英镑一节的钢琴和古典吉他课都要昂贵。但是学会欣赏插花，陶艺，钢琴和古典吉他却并不一定需要交学费。当别人都在处心积虑地想多赚一点家用和奶粉钱的时候，你若能停下来，走到公园里去看花，或者在经过别人家的花园时，多看几眼别人的花，就已经迈过了艺术那高高在上的门槛。 第五：不做无意义的旅行没钱旅行？那就不要旅行。葡萄牙作家Femando Pessoa一生都没有离开过他生活的道拉多雷斯大街。意大利画家Giorgio Morandi 也一辈子没有离开过意大利。像那种带领4000大军游罗浮宫的土豪式旅行，或者在希腊的Kos岛一边海喝，一边抱怨“叙利亚和阿富汗难民如何把希腊海岛变成贫民窟”之类的仇恨旅行，还是不要参与为好。伍迪艾伦说：“金钱买不到快乐，但是金钱可以买到高品质的杯具，”说的正是如此。 第六：读书，读书，读书最后，多读书吧！读书不能帮助你致富，却能帮助你理解这个世界的贫困成因，让你不再对自己失望，让你不再以贫为耻。","categories":[{"name":"生活","slug":"生活","permalink":"http://www.gistop.com/categories/生活/"},{"name":"格调","slug":"生活/格调","permalink":"http://www.gistop.com/categories/生活/格调/"}],"tags":[]}]}